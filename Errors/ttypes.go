// Autogenerated by Thrift Compiler (0.9.1)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

package Errors

import (
	"fmt"
	"git.apache.org/thrift.git/lib/go/thrift"
	"math"
)

// (needed to ensure safety because of naive import list construction.)
var _ = math.MinInt32
var _ = thrift.ZERO
var _ = fmt.Printf

var GoUnusedProtection__ int

//Numeric codes indicating the type of error that occurred on the
//service.
//<dl>
//  <dt>UNKNOWN</dt>
//    <dd>No information available about the error</dd>
//  <dt>BAD_DATA_FORMAT</dt>
//    <dd>The format of the request data was incorrect</dd>
//  <dt>PERMISSION_DENIED</dt>
//    <dd>Not permitted to perform action</dd>
//  <dt>INTERNAL_ERROR</dt>
//    <dd>Unexpected problem with the service</dd>
//  <dt>DATA_REQUIRED</dt>
//    <dd>A required parameter/field was absent</dd>
//  <dt>LIMIT_REACHED</dt>
//    <dd>Operation denied due to data model limit</dd>
//  <dt>QUOTA_REACHED</dt>
//    <dd>Operation denied due to user storage limit</dd>
//  <dt>INVALID_AUTH</dt>
//    <dd>Username and/or password incorrect</dd>
//  <dt>AUTH_EXPIRED</dt>
//    <dd>Authentication token expired</dd>
//  <dt>DATA_CONFLICT</dt>
//    <dd>Change denied due to data model conflict</dd>
//  <dt>ENML_VALIDATION</dt>
//    <dd>Content of submitted note was malformed</dd>
//  <dt>SHARD_UNAVAILABLE</dt>
//    <dd>Service shard with account data is temporarily down</dd>
//  <dt>LEN_TOO_SHORT</dt>
//    <dd>Operation denied due to data model limit, where something such
//        as a string length was too short</dd>
//  <dt>LEN_TOO_LONG</dt>
//    <dd>Operation denied due to data model limit, where something such
//        as a string length was too long</dd>
//  <dt>TOO_FEW</dt>
//    <dd>Operation denied due to data model limit, where there were
//        too few of something.</dd>
//  <dt>TOO_MANY</dt>
//    <dd>Operation denied due to data model limit, where there were
//        too many of something.</dd>
//  <dt>UNSUPPORTED_OPERATION</dt>
//    <dd>Operation denied because it is currently unsupported.</dd>
//  <dt>TAKEN_DOWN</dt>
//    <dd>Operation denied because access to the corresponding object is
//        prohibited in response to a take-down notice.</dd>
//  <dt>RATE_LIMIT_REACHED</dt>
//    <dd>Operation denied because the calling application has reached
//        its hourly API call limit for this user.</dd>
//</dl>
type EDAMErrorCode int64

const (
	EDAMErrorCode_UNKNOWN               EDAMErrorCode = 1
	EDAMErrorCode_BAD_DATA_FORMAT       EDAMErrorCode = 2
	EDAMErrorCode_PERMISSION_DENIED     EDAMErrorCode = 3
	EDAMErrorCode_INTERNAL_ERROR        EDAMErrorCode = 4
	EDAMErrorCode_DATA_REQUIRED         EDAMErrorCode = 5
	EDAMErrorCode_LIMIT_REACHED         EDAMErrorCode = 6
	EDAMErrorCode_QUOTA_REACHED         EDAMErrorCode = 7
	EDAMErrorCode_INVALID_AUTH          EDAMErrorCode = 8
	EDAMErrorCode_AUTH_EXPIRED          EDAMErrorCode = 9
	EDAMErrorCode_DATA_CONFLICT         EDAMErrorCode = 10
	EDAMErrorCode_ENML_VALIDATION       EDAMErrorCode = 11
	EDAMErrorCode_SHARD_UNAVAILABLE     EDAMErrorCode = 12
	EDAMErrorCode_LEN_TOO_SHORT         EDAMErrorCode = 13
	EDAMErrorCode_LEN_TOO_LONG          EDAMErrorCode = 14
	EDAMErrorCode_TOO_FEW               EDAMErrorCode = 15
	EDAMErrorCode_TOO_MANY              EDAMErrorCode = 16
	EDAMErrorCode_UNSUPPORTED_OPERATION EDAMErrorCode = 17
	EDAMErrorCode_TAKEN_DOWN            EDAMErrorCode = 18
	EDAMErrorCode_RATE_LIMIT_REACHED    EDAMErrorCode = 19
)

func (p EDAMErrorCode) String() string {
	switch p {
	case EDAMErrorCode_UNKNOWN:
		return "EDAMErrorCode_UNKNOWN"
	case EDAMErrorCode_BAD_DATA_FORMAT:
		return "EDAMErrorCode_BAD_DATA_FORMAT"
	case EDAMErrorCode_PERMISSION_DENIED:
		return "EDAMErrorCode_PERMISSION_DENIED"
	case EDAMErrorCode_INTERNAL_ERROR:
		return "EDAMErrorCode_INTERNAL_ERROR"
	case EDAMErrorCode_DATA_REQUIRED:
		return "EDAMErrorCode_DATA_REQUIRED"
	case EDAMErrorCode_LIMIT_REACHED:
		return "EDAMErrorCode_LIMIT_REACHED"
	case EDAMErrorCode_QUOTA_REACHED:
		return "EDAMErrorCode_QUOTA_REACHED"
	case EDAMErrorCode_INVALID_AUTH:
		return "EDAMErrorCode_INVALID_AUTH"
	case EDAMErrorCode_AUTH_EXPIRED:
		return "EDAMErrorCode_AUTH_EXPIRED"
	case EDAMErrorCode_DATA_CONFLICT:
		return "EDAMErrorCode_DATA_CONFLICT"
	case EDAMErrorCode_ENML_VALIDATION:
		return "EDAMErrorCode_ENML_VALIDATION"
	case EDAMErrorCode_SHARD_UNAVAILABLE:
		return "EDAMErrorCode_SHARD_UNAVAILABLE"
	case EDAMErrorCode_LEN_TOO_SHORT:
		return "EDAMErrorCode_LEN_TOO_SHORT"
	case EDAMErrorCode_LEN_TOO_LONG:
		return "EDAMErrorCode_LEN_TOO_LONG"
	case EDAMErrorCode_TOO_FEW:
		return "EDAMErrorCode_TOO_FEW"
	case EDAMErrorCode_TOO_MANY:
		return "EDAMErrorCode_TOO_MANY"
	case EDAMErrorCode_UNSUPPORTED_OPERATION:
		return "EDAMErrorCode_UNSUPPORTED_OPERATION"
	case EDAMErrorCode_TAKEN_DOWN:
		return "EDAMErrorCode_TAKEN_DOWN"
	case EDAMErrorCode_RATE_LIMIT_REACHED:
		return "EDAMErrorCode_RATE_LIMIT_REACHED"
	}
	return "<UNSET>"
}

func EDAMErrorCodeFromString(s string) (EDAMErrorCode, error) {
	switch s {
	case "EDAMErrorCode_UNKNOWN":
		return EDAMErrorCode_UNKNOWN, nil
	case "EDAMErrorCode_BAD_DATA_FORMAT":
		return EDAMErrorCode_BAD_DATA_FORMAT, nil
	case "EDAMErrorCode_PERMISSION_DENIED":
		return EDAMErrorCode_PERMISSION_DENIED, nil
	case "EDAMErrorCode_INTERNAL_ERROR":
		return EDAMErrorCode_INTERNAL_ERROR, nil
	case "EDAMErrorCode_DATA_REQUIRED":
		return EDAMErrorCode_DATA_REQUIRED, nil
	case "EDAMErrorCode_LIMIT_REACHED":
		return EDAMErrorCode_LIMIT_REACHED, nil
	case "EDAMErrorCode_QUOTA_REACHED":
		return EDAMErrorCode_QUOTA_REACHED, nil
	case "EDAMErrorCode_INVALID_AUTH":
		return EDAMErrorCode_INVALID_AUTH, nil
	case "EDAMErrorCode_AUTH_EXPIRED":
		return EDAMErrorCode_AUTH_EXPIRED, nil
	case "EDAMErrorCode_DATA_CONFLICT":
		return EDAMErrorCode_DATA_CONFLICT, nil
	case "EDAMErrorCode_ENML_VALIDATION":
		return EDAMErrorCode_ENML_VALIDATION, nil
	case "EDAMErrorCode_SHARD_UNAVAILABLE":
		return EDAMErrorCode_SHARD_UNAVAILABLE, nil
	case "EDAMErrorCode_LEN_TOO_SHORT":
		return EDAMErrorCode_LEN_TOO_SHORT, nil
	case "EDAMErrorCode_LEN_TOO_LONG":
		return EDAMErrorCode_LEN_TOO_LONG, nil
	case "EDAMErrorCode_TOO_FEW":
		return EDAMErrorCode_TOO_FEW, nil
	case "EDAMErrorCode_TOO_MANY":
		return EDAMErrorCode_TOO_MANY, nil
	case "EDAMErrorCode_UNSUPPORTED_OPERATION":
		return EDAMErrorCode_UNSUPPORTED_OPERATION, nil
	case "EDAMErrorCode_TAKEN_DOWN":
		return EDAMErrorCode_TAKEN_DOWN, nil
	case "EDAMErrorCode_RATE_LIMIT_REACHED":
		return EDAMErrorCode_RATE_LIMIT_REACHED, nil
	}
	return EDAMErrorCode(math.MinInt32 - 1), fmt.Errorf("not a valid EDAMErrorCode string")
}

type EDAMUserException struct {
	ErrorCode EDAMErrorCode `thrift:"errorCode,1,required"`
	Parameter string        `thrift:"parameter,2"`
}

func NewEDAMUserException() *EDAMUserException {
	return &EDAMUserException{
		ErrorCode: math.MinInt32 - 1, // unset sentinal value
	}
}

func (p *EDAMUserException) IsSetErrorCode() bool {
	return int64(p.ErrorCode) != math.MinInt32-1
}

func (p *EDAMUserException) IsSetParameter() bool {
	return p.Parameter != ""
}

func (p *EDAMUserException) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *EDAMUserException) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.ErrorCode = EDAMErrorCode(v)
	}
	return nil
}

func (p *EDAMUserException) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.Parameter = v
	}
	return nil
}

func (p *EDAMUserException) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("EDAMUserException"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *EDAMUserException) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetErrorCode() {
		if err := oprot.WriteFieldBegin("errorCode", thrift.I32, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:errorCode: %s", p, err)
		}
		if err := oprot.WriteI32(int32(p.ErrorCode)); err != nil {
			return fmt.Errorf("%T.errorCode (1) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:errorCode: %s", p, err)
		}
	}
	return err
}

func (p *EDAMUserException) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetParameter() {
		if err := oprot.WriteFieldBegin("parameter", thrift.STRING, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:parameter: %s", p, err)
		}
		if err := oprot.WriteString(string(p.Parameter)); err != nil {
			return fmt.Errorf("%T.parameter (2) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:parameter: %s", p, err)
		}
	}
	return err
}

func (p *EDAMUserException) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("EDAMUserException(%+v)", *p)
}

type EDAMSystemException struct {
	ErrorCode         EDAMErrorCode `thrift:"errorCode,1,required"`
	Message           string        `thrift:"message,2"`
	RateLimitDuration int32         `thrift:"rateLimitDuration,3"`
}

func NewEDAMSystemException() *EDAMSystemException {
	return &EDAMSystemException{
		ErrorCode: math.MinInt32 - 1, // unset sentinal value
	}
}

func (p *EDAMSystemException) IsSetErrorCode() bool {
	return int64(p.ErrorCode) != math.MinInt32-1
}

func (p *EDAMSystemException) IsSetMessage() bool {
	return p.Message != ""
}

func (p *EDAMSystemException) IsSetRateLimitDuration() bool {
	return p.RateLimitDuration != 0
}

func (p *EDAMSystemException) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *EDAMSystemException) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.ErrorCode = EDAMErrorCode(v)
	}
	return nil
}

func (p *EDAMSystemException) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.Message = v
	}
	return nil
}

func (p *EDAMSystemException) readField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 3: %s")
	} else {
		p.RateLimitDuration = v
	}
	return nil
}

func (p *EDAMSystemException) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("EDAMSystemException"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *EDAMSystemException) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetErrorCode() {
		if err := oprot.WriteFieldBegin("errorCode", thrift.I32, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:errorCode: %s", p, err)
		}
		if err := oprot.WriteI32(int32(p.ErrorCode)); err != nil {
			return fmt.Errorf("%T.errorCode (1) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:errorCode: %s", p, err)
		}
	}
	return err
}

func (p *EDAMSystemException) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetMessage() {
		if err := oprot.WriteFieldBegin("message", thrift.STRING, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:message: %s", p, err)
		}
		if err := oprot.WriteString(string(p.Message)); err != nil {
			return fmt.Errorf("%T.message (2) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:message: %s", p, err)
		}
	}
	return err
}

func (p *EDAMSystemException) writeField3(oprot thrift.TProtocol) (err error) {
	if p.IsSetRateLimitDuration() {
		if err := oprot.WriteFieldBegin("rateLimitDuration", thrift.I32, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:rateLimitDuration: %s", p, err)
		}
		if err := oprot.WriteI32(int32(p.RateLimitDuration)); err != nil {
			return fmt.Errorf("%T.rateLimitDuration (3) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:rateLimitDuration: %s", p, err)
		}
	}
	return err
}

func (p *EDAMSystemException) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("EDAMSystemException(%+v)", *p)
}

type EDAMNotFoundException struct {
	Identifier string `thrift:"identifier,1"`
	Key        string `thrift:"key,2"`
}

func NewEDAMNotFoundException() *EDAMNotFoundException {
	return &EDAMNotFoundException{}
}

func (p *EDAMNotFoundException) IsSetIdentifier() bool {
	return p.Identifier != ""
}

func (p *EDAMNotFoundException) IsSetKey() bool {
	return p.Key != ""
}

func (p *EDAMNotFoundException) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *EDAMNotFoundException) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Identifier = v
	}
	return nil
}

func (p *EDAMNotFoundException) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.Key = v
	}
	return nil
}

func (p *EDAMNotFoundException) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("EDAMNotFoundException"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *EDAMNotFoundException) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIdentifier() {
		if err := oprot.WriteFieldBegin("identifier", thrift.STRING, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:identifier: %s", p, err)
		}
		if err := oprot.WriteString(string(p.Identifier)); err != nil {
			return fmt.Errorf("%T.identifier (1) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:identifier: %s", p, err)
		}
	}
	return err
}

func (p *EDAMNotFoundException) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetKey() {
		if err := oprot.WriteFieldBegin("key", thrift.STRING, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:key: %s", p, err)
		}
		if err := oprot.WriteString(string(p.Key)); err != nil {
			return fmt.Errorf("%T.key (2) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:key: %s", p, err)
		}
	}
	return err
}

func (p *EDAMNotFoundException) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("EDAMNotFoundException(%+v)", *p)
}
