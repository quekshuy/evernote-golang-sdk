// Autogenerated by Thrift Compiler (0.9.1)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

package UserStore

import (
	"Errors"
	"Types"
	"fmt"
	"git.apache.org/thrift.git/lib/go/thrift"
	"math"
)

// (needed to ensure safety because of naive import list construction.)
var _ = math.MinInt32
var _ = thrift.ZERO
var _ = fmt.Printf

var _ = Types.GoUnusedProtection__
var _ = Errors.GoUnusedProtection__

type UserStore interface { //Service:  UserStore
	//<p>
	//The UserStore service is primarily used by EDAM clients to establish
	//authentication via username and password over a trusted connection (e.g.
	//SSL).  A client's first call to this interface should be checkVersion() to
	//ensure that the client's software is up to date.
	//</p>
	//All calls which require an authenticationToken may throw an
	//EDAMUserException for the following reasons:
	// <ul>
	//  <li> AUTH_EXPIRED "authenticationToken" - token has expired
	//  <li> BAD_DATA_FORMAT "authenticationToken" - token is malformed
	//  <li> DATA_REQUIRED "authenticationToken" - token is empty
	//  <li> INVALID_AUTH "authenticationToken" - token signature is invalid
	//</ul>

	// This should be the first call made by a client to the EDAM service.  It
	// tells the service what protocol version is used by the client.  The
	// service will then return true if the client is capable of talking to
	// the service, and false if the client's protocol version is incompatible
	// with the service, so the client must upgrade.  If a client receives a
	// false value, it should report the incompatibility to the user and not
	// continue with any more EDAM requests (UserStore or NoteStore).
	//
	// @param clientName
	//   This string provides some information about the client for
	//   tracking/logging on the service.  It should provide information about
	//   the client's software and platform. The structure should be:
	//   application/version; platform/version; [ device/version ]
	//   E.g. "Evernote Windows/3.0.1; Windows/XP SP3".
	//
	// @param edamVersionMajor
	//   This should be the major protocol version that was compiled by the
	//   client.  This should be the current value of the EDAM_VERSION_MAJOR
	//   constant for the client.
	//
	// @param edamVersionMinor
	//   This should be the major protocol version that was compiled by the
	//   client.  This should be the current value of the EDAM_VERSION_MINOR
	//   constant for the client.
	//
	// Parameters:
	//  - ClientName
	//  - EdamVersionMajor
	//  - EdamVersionMinor
	CheckVersion(clientName string, edamVersionMajor int16, edamVersionMinor int16) (r bool, err error)
	// This provides bootstrap information to the client. Various bootstrap
	// profiles and settings may be used by the client to configure itself.
	//
	// @param locale
	//   The client's current locale, expressed in language[_country]
	//   format. E.g., "en_US". See ISO-639 and ISO-3166 for valid
	//   language and country codes.
	//
	// @return
	//   The bootstrap information suitable for this client.
	//
	// Parameters:
	//  - Locale
	GetBootstrapInfo(locale string) (r *BootstrapInfo, err error)
	// This is used to check a username and password in order to create a
	// short-lived authentication session that can be used for further actions.
	//
	// This function is only available to Evernote's internal applications.
	// Third party applications must authenticate using OAuth as
	// described at
	// <a href="http://dev.evernote.com/documentation/cloud/">dev.evernote.com</a>.
	//
	// @param username
	//   The username (not numeric user ID) for the account to
	//   authenticate against.  This function will also accept the user's
	//   registered email address in this parameter.
	//
	// @param password
	//   The plaintext password to check against the account.  Since
	//   this is not protected by the EDAM protocol, this information must be
	//   provided over a protected transport (e.g. SSL).
	//
	// @param consumerKey
	//   The "consumer key" portion of the API key issued to the client application
	//   by Evernote.
	//
	// @param consumerSecret
	//   The "consumer secret" portion of the API key issued to the client application
	//   by Evernote.
	//
	// @param supportsTwoFactor
	//   Whether the calling application supports two-factor authentication. If this
	//   parameter is false, this method will fail with the error code INVALID_AUTH and the
	//   parameter "password" when called for a user who has enabled two-factor
	//   authentication.
	//
	// @return
	//   <p>The result of the authentication.  If the authentication was successful,
	//   the AuthenticationResult.user field will be set with the full information
	//   about the User.</p>
	//   <p>If the user has two-factor authentication enabled,
	//   AuthenticationResult.secondFactorRequired will be set and
	//   AuthenticationResult.authenticationToken will contain a short-lived token
	//   that may only be used to complete the two-factor authentication process by calling
	//   UserStore.completeTwoFactorAuthentication.</p>
	//
	// @throws EDAMUserException <ul>
	//   <li> DATA_REQUIRED "username" - username is empty
	//   <li> DATA_REQUIRED "password" - password is empty
	//   <li> DATA_REQUIRED "consumerKey" - consumerKey is empty
	//   <li> INVALID_AUTH "username" - username not found
	//   <li> INVALID_AUTH "password" - password did not match
	//   <li> INVALID_AUTH "consumerKey" - consumerKey is not authorized
	//   <li> INVALID_AUTH "consumerSecret" - consumerSecret is incorrect
	//   <li> PERMISSION_DENIED "User.active" - user account is closed
	//   <li> PERMISSION_DENIED "User.tooManyFailuresTryAgainLater" - user has
	//     failed authentication too often
	// </ul>
	//
	// Parameters:
	//  - Username
	//  - Password
	//  - ConsumerKey
	//  - ConsumerSecret
	//  - SupportsTwoFactor
	Authenticate(username string, password string, consumerKey string, consumerSecret string, supportsTwoFactor bool) (r *AuthenticationResult, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, err error)
	// This is used to check a username and password in order to create a
	// long-lived authentication token that can be used for further actions.
	//
	// This function is not available to most third party applications,
	// which typically authenticate using OAuth as
	// described at
	// <a href="http://dev.evernote.com/documentation/cloud/">dev.evernote.com</a>.
	// If you believe that your application requires permission to authenticate
	// using username and password instead of OAuth, please contact Evernote
	// developer support by visiting
	// <a href="http://dev.evernote.com">dev.evernote.com</a>.
	//
	// @param username
	//   The username or registered email address of the account to
	//   authenticate against.
	//
	// @param password
	//   The plaintext password to check against the account.  Since
	//   this is not protected by the EDAM protocol, this information must be
	//   provided over a protected transport (i.e. SSL).
	//
	// @param consumerKey
	//   The "consumer key" portion of the API key issued to the client application
	//   by Evernote.
	//
	// @param consumerSecret
	//   The "consumer secret" portion of the API key issued to the client application
	//   by Evernote.
	//
	// @param deviceIdentifier
	//   An optional string, no more than 32 characters in length, that uniquely identifies
	//   the device from which the authentication is being performed. This string allows
	//   the service to return the same authentication token when a given application
	//   requests authentication repeatedly from the same device. This may happen when the
	//   user logs out of an application and then logs back in, or when the application is
	//   uninstalled and later reinstalled. If no reliable device identifier can be created,
	//   this value should be omitted. If set, the device identifier must be between
	//   1 and EDAM_DEVICE_ID_LEN_MAX characters long and must match the regular expression
	//   EDAM_DEVICE_ID_REGEX.
	//
	// @param deviceDescription
	//   A description of the device from which the authentication is being performed.
	//   This field is displayed to the user in a list of authorized applications to
	//   allow them to distinguish between multiple tokens issued to the same client
	//   application on different devices. For example, the Evernote iOS client on
	//   a user's iPhone and iPad might pass the iOS device names "Bob's iPhone" and
	//   "Bob's iPad". The device description must be between 1 and
	//   EDAM_DEVICE_DESCRIPTION_LEN_MAX characters long and must match the regular
	//   expression EDAM_DEVICE_DESCRIPTION_REGEX.
	//
	// @param supportsTwoFactor
	//   Whether the calling application supports two-factor authentication. If this
	//   parameter is false, this method will fail with the error code INVALID_AUTH and the
	//   parameter "password" when called for a user who has enabled two-factor
	//   authentication.
	//
	// @return
	//   <p>The result of the authentication. The level of detail provided in the returned
	//   AuthenticationResult.User structure depends on the access level granted by
	//   calling application's API key.</p>
	//   <p>If the user has two-factor authentication enabled,
	//   AuthenticationResult.secondFactorRequired will be set and
	//   AuthenticationResult.authenticationToken will contain a short-lived token
	//   that may only be used to complete the two-factor authentication process by calling
	//   UserStore.completeTwoFactorAuthentication.</p>
	//
	// @throws EDAMUserException <ul>
	//   <li> DATA_REQUIRED "username" - username is empty
	//   <li> DATA_REQUIRED "password" - password is empty
	//   <li> DATA_REQUIRED "consumerKey" - consumerKey is empty
	//   <li> DATA_REQUIRED "consumerSecret" - consumerSecret is empty
	//   <li> DATA_REQUIRED "deviceDescription" - deviceDescription is empty
	//   <li> BAD_DATA_FORMAT "deviceDescription" - deviceDescription is not valid.
	//   <li> BAD_DATA_FORMAT "deviceIdentifier" - deviceIdentifier is not valid.
	//   <li> INVALID_AUTH "username" - username not found
	//   <li> INVALID_AUTH "password" - password did not match
	//   <li> INVALID_AUTH "consumerKey" - consumerKey is not authorized
	//   <li> INVALID_AUTH "consumerSecret" - consumerSecret is incorrect
	//   <li> PERMISSION_DENIED "User.active" - user account is closed
	//   <li> PERMISSION_DENIED "User.tooManyFailuresTryAgainLater" - user has
	//     failed authentication too often
	// </ul>
	//
	// Parameters:
	//  - Username
	//  - Password
	//  - ConsumerKey
	//  - ConsumerSecret
	//  - DeviceIdentifier
	//  - DeviceDescription
	//  - SupportsTwoFactor
	AuthenticateLongSession(username string, password string, consumerKey string, consumerSecret string, deviceIdentifier string, deviceDescription string, supportsTwoFactor bool) (r *AuthenticationResult, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, err error)
	// Complete the authentication process when a second factor is required. This
	// call is made after a successful call to authenticate or authenticateLongSession
	// when the authenticating user has enabled two-factor authentication.
	//
	// @param authenticationToken An authentication token returned by a previous
	//   call to UserStore.authenticate or UserStore.authenticateLongSession that
	//   could not be completed in a single call because a second factor was required.
	//
	// @param oneTimeCode The one time code entered by the user. This value is delivered
	//   out-of-band, typically via SMS or an authenticator application.
	//
	// @param deviceIdentifier See the corresponding parameter in authenticateLongSession.
	//
	// @param deviceDescription See the corresponding parameter in authenticateLongSession.
	//
	// @return
	//   The result of the authentication. The level of detail provided in the returned
	//   AuthenticationResult.User structure depends on the access level granted by the
	//   calling application's API key. If the initial authentication call was made to
	//   authenticateLongSession, the AuthenticationResult will contain a long-lived
	//   authentication token.
	//
	// @throws EDAMUserException <ul>
	//   <li> DATA_REQUIRED "authenticationToken" - authenticationToken is empty
	//   <li> DATA_REQUIRED "oneTimeCode" - oneTimeCode is empty
	//   <li> BAD_DATA_FORMAT "authenticationToken" - authenticationToken is not well formed
	//   <li> INVALID_AUTH "oneTimeCode" - oneTimeCode did not match
	//   <li> AUTH_EXPIRED "authenticationToken" - authenticationToken has expired
	//   <li> PERMISSION_DENIED "authenticationToken" - authenticationToken is not valid
	//   <li> PERMISSION_DENIED "User.active" - user account is closed
	//   <li> PERMISSION_DENIED "User.tooManyFailuresTryAgainLater" - user has
	//     failed authentication too often
	//   <li> DATA_CONFLICT "User.twoFactorAuthentication" - The user has not enabled
	//      two-factor authentication.</li>
	// </ul>
	//
	// Parameters:
	//  - AuthenticationToken
	//  - OneTimeCode
	//  - DeviceIdentifier
	//  - DeviceDescription
	CompleteTwoFactorAuthentication(authenticationToken string, oneTimeCode string, deviceIdentifier string, deviceDescription string) (r *AuthenticationResult, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, err error)
	// Revoke an existing long lived authentication token. This can be used to
	// revoke OAuth tokens or tokens created by calling authenticateLongSession,
	// and allows a user to effectively log out of Evernote from the perspective
	// of the application that holds the token. The authentication token that is
	// passed is immediately revoked and may not be used to call any authenticated
	// EDAM function.
	//
	// @param authenticationToken the authentication token to revoke.
	//
	// @throws EDAMUserException <ul>
	//   <li> DATA_REQUIRED "authenticationToken" - no authentication token provided
	//   <li> BAD_DATA_FORMAT "authenticationToken" - the authentication token is not well formed
	//   <li> INVALID_AUTH "authenticationToken" - the authentication token is invalid
	//   <li> AUTH_EXPIRED "authenticationToken" - the authentication token is expired or
	//     is already revoked.
	// </ul>
	//
	// Parameters:
	//  - AuthenticationToken
	RevokeLongSession(authenticationToken string) (userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, err error)
	// This is used to take an existing authentication token that grants access
	// to an individual user account (returned from 'authenticate',
	// 'authenticateLongSession' or an OAuth authorization) and obtain an additional
	// authentication token that may be used to access business notebooks if the user
	// is a member of an Evernote Business account.
	//
	// The resulting authentication token may be used to make NoteStore API calls
	// against the business using the NoteStore URL returned in the result.
	//
	// @param authenticationToken
	//   The authentication token for the user. This may not be a shared authentication
	//   token (returned by NoteStore.authenticateToSharedNotebook or
	//   NoteStore.authenticateToSharedNote) or a business authentication token.
	//
	// @return
	//   The result of the authentication, with the token granting access to the
	//   business in the result's 'authenticationToken' field. The URL that must
	//   be used to access the business account NoteStore will be returned in the
	//   result's 'noteStoreUrl' field.  The 'User' field will
	//   not be set in the result.
	//
	// @throws EDAMUserException <ul>
	//   <li> PERMISSION_DENIED "authenticationToken" - the provided authentication token
	//        is a shared or business authentication token. </li>
	//   <li> PERMISSION_DENIED "Business" - the user identified by the provided
	//        authentication token is not currently a member of a business. </li>
	//   <li> PERMISSION_DENIED "Business.status" - the business that the user is a
	//        member of is not currently in an active status. </li>
	// </ul>
	//
	// Parameters:
	//  - AuthenticationToken
	AuthenticateToBusiness(authenticationToken string) (r *AuthenticationResult, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, err error)
	// This is used to take an existing authentication token (returned from
	// 'authenticate') and exchange it for a newer token which will not expire
	// as soon.  This must be invoked before the previous token expires.
	//
	// This function is only availabe to Evernote's internal applications.
	//
	// @param authenticationToken
	//   The previous authentication token from the authenticate() result.
	//
	// @return
	//   The result of the authentication, with the new token in
	//   the result's 'authenticationToken' field.  The 'User' field will
	//   not be set in the result.
	//
	// Parameters:
	//  - AuthenticationToken
	RefreshAuthentication(authenticationToken string) (r *AuthenticationResult, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, err error)
	// Returns the User corresponding to the provided authentication token,
	// or throws an exception if this token is not valid.
	// The level of detail provided in the returned User structure depends on
	// the access level granted by the token, so a web service client may receive
	// fewer fields than an integrated desktop client.
	//
	// Parameters:
	//  - AuthenticationToken
	GetUser(authenticationToken string) (r *Types.User, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, err error)
	// Asks the UserStore about the publicly available location information for
	// a particular username.
	//
	// @throws EDAMUserException <ul>
	//   <li> DATA_REQUIRED "username" - username is empty
	// </ul>
	//
	// Parameters:
	//  - Username
	GetPublicUserInfo(username string) (r *PublicUserInfo, notFoundException *Errors.EDAMNotFoundException, systemException *Errors.EDAMSystemException, userException *Errors.EDAMUserException, err error)
	// Returns information regarding a user's Premium account corresponding to the
	// provided authentication token, or throws an exception if this token is not
	// valid.
	//
	// Parameters:
	//  - AuthenticationToken
	GetPremiumInfo(authenticationToken string) (r *Types.PremiumInfo, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, err error)
	// Returns the URL that should be used to talk to the NoteStore for the
	// account represented by the provided authenticationToken.
	// This method isn't needed by most clients, who can retrieve the correct
	// NoteStore URL from the AuthenticationResult returned from the authenticate
	// or refreshAuthentication calls. This method is typically only needed
	// to look up the correct URL for a long-lived session token (e.g. for an
	// OAuth web service).
	//
	// Parameters:
	//  - AuthenticationToken
	GetNoteStoreUrl(authenticationToken string) (r string, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, err error)
}

//Service:  UserStore
//<p>
//The UserStore service is primarily used by EDAM clients to establish
//authentication via username and password over a trusted connection (e.g.
//SSL).  A client's first call to this interface should be checkVersion() to
//ensure that the client's software is up to date.
//</p>
//All calls which require an authenticationToken may throw an
//EDAMUserException for the following reasons:
// <ul>
//  <li> AUTH_EXPIRED "authenticationToken" - token has expired
//  <li> BAD_DATA_FORMAT "authenticationToken" - token is malformed
//  <li> DATA_REQUIRED "authenticationToken" - token is empty
//  <li> INVALID_AUTH "authenticationToken" - token signature is invalid
//</ul>
type UserStoreClient struct {
	Transport       thrift.TTransport
	ProtocolFactory thrift.TProtocolFactory
	InputProtocol   thrift.TProtocol
	OutputProtocol  thrift.TProtocol
	SeqId           int32
}

func NewUserStoreClientFactory(t thrift.TTransport, f thrift.TProtocolFactory) *UserStoreClient {
	return &UserStoreClient{Transport: t,
		ProtocolFactory: f,
		InputProtocol:   f.GetProtocol(t),
		OutputProtocol:  f.GetProtocol(t),
		SeqId:           0,
	}
}

func NewUserStoreClientProtocol(t thrift.TTransport, iprot thrift.TProtocol, oprot thrift.TProtocol) *UserStoreClient {
	return &UserStoreClient{Transport: t,
		ProtocolFactory: nil,
		InputProtocol:   iprot,
		OutputProtocol:  oprot,
		SeqId:           0,
	}
}

// This should be the first call made by a client to the EDAM service.  It
// tells the service what protocol version is used by the client.  The
// service will then return true if the client is capable of talking to
// the service, and false if the client's protocol version is incompatible
// with the service, so the client must upgrade.  If a client receives a
// false value, it should report the incompatibility to the user and not
// continue with any more EDAM requests (UserStore or NoteStore).
//
// @param clientName
//   This string provides some information about the client for
//   tracking/logging on the service.  It should provide information about
//   the client's software and platform. The structure should be:
//   application/version; platform/version; [ device/version ]
//   E.g. "Evernote Windows/3.0.1; Windows/XP SP3".
//
// @param edamVersionMajor
//   This should be the major protocol version that was compiled by the
//   client.  This should be the current value of the EDAM_VERSION_MAJOR
//   constant for the client.
//
// @param edamVersionMinor
//   This should be the major protocol version that was compiled by the
//   client.  This should be the current value of the EDAM_VERSION_MINOR
//   constant for the client.
//
// Parameters:
//  - ClientName
//  - EdamVersionMajor
//  - EdamVersionMinor
func (p *UserStoreClient) CheckVersion(clientName string, edamVersionMajor int16, edamVersionMinor int16) (r bool, err error) {
	if err = p.sendCheckVersion(clientName, edamVersionMajor, edamVersionMinor); err != nil {
		return
	}
	return p.recvCheckVersion()
}

func (p *UserStoreClient) sendCheckVersion(clientName string, edamVersionMajor int16, edamVersionMinor int16) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("checkVersion", thrift.CALL, p.SeqId)
	args1 := NewCheckVersionArgs()
	args1.ClientName = clientName
	args1.EdamVersionMajor = edamVersionMajor
	args1.EdamVersionMinor = edamVersionMinor
	err = args1.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *UserStoreClient) recvCheckVersion() (value bool, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error3 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error4 error
		error4, err = error3.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error4
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result2 := NewCheckVersionResult()
	err = result2.Read(iprot)
	iprot.ReadMessageEnd()
	value = result2.Success
	return
}

// This provides bootstrap information to the client. Various bootstrap
// profiles and settings may be used by the client to configure itself.
//
// @param locale
//   The client's current locale, expressed in language[_country]
//   format. E.g., "en_US". See ISO-639 and ISO-3166 for valid
//   language and country codes.
//
// @return
//   The bootstrap information suitable for this client.
//
// Parameters:
//  - Locale
func (p *UserStoreClient) GetBootstrapInfo(locale string) (r *BootstrapInfo, err error) {
	if err = p.sendGetBootstrapInfo(locale); err != nil {
		return
	}
	return p.recvGetBootstrapInfo()
}

func (p *UserStoreClient) sendGetBootstrapInfo(locale string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("getBootstrapInfo", thrift.CALL, p.SeqId)
	args5 := NewGetBootstrapInfoArgs()
	args5.Locale = locale
	err = args5.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *UserStoreClient) recvGetBootstrapInfo() (value *BootstrapInfo, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error7 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error8 error
		error8, err = error7.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error8
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result6 := NewGetBootstrapInfoResult()
	err = result6.Read(iprot)
	iprot.ReadMessageEnd()
	value = result6.Success
	return
}

// This is used to check a username and password in order to create a
// short-lived authentication session that can be used for further actions.
//
// This function is only available to Evernote's internal applications.
// Third party applications must authenticate using OAuth as
// described at
// <a href="http://dev.evernote.com/documentation/cloud/">dev.evernote.com</a>.
//
// @param username
//   The username (not numeric user ID) for the account to
//   authenticate against.  This function will also accept the user's
//   registered email address in this parameter.
//
// @param password
//   The plaintext password to check against the account.  Since
//   this is not protected by the EDAM protocol, this information must be
//   provided over a protected transport (e.g. SSL).
//
// @param consumerKey
//   The "consumer key" portion of the API key issued to the client application
//   by Evernote.
//
// @param consumerSecret
//   The "consumer secret" portion of the API key issued to the client application
//   by Evernote.
//
// @param supportsTwoFactor
//   Whether the calling application supports two-factor authentication. If this
//   parameter is false, this method will fail with the error code INVALID_AUTH and the
//   parameter "password" when called for a user who has enabled two-factor
//   authentication.
//
// @return
//   <p>The result of the authentication.  If the authentication was successful,
//   the AuthenticationResult.user field will be set with the full information
//   about the User.</p>
//   <p>If the user has two-factor authentication enabled,
//   AuthenticationResult.secondFactorRequired will be set and
//   AuthenticationResult.authenticationToken will contain a short-lived token
//   that may only be used to complete the two-factor authentication process by calling
//   UserStore.completeTwoFactorAuthentication.</p>
//
// @throws EDAMUserException <ul>
//   <li> DATA_REQUIRED "username" - username is empty
//   <li> DATA_REQUIRED "password" - password is empty
//   <li> DATA_REQUIRED "consumerKey" - consumerKey is empty
//   <li> INVALID_AUTH "username" - username not found
//   <li> INVALID_AUTH "password" - password did not match
//   <li> INVALID_AUTH "consumerKey" - consumerKey is not authorized
//   <li> INVALID_AUTH "consumerSecret" - consumerSecret is incorrect
//   <li> PERMISSION_DENIED "User.active" - user account is closed
//   <li> PERMISSION_DENIED "User.tooManyFailuresTryAgainLater" - user has
//     failed authentication too often
// </ul>
//
// Parameters:
//  - Username
//  - Password
//  - ConsumerKey
//  - ConsumerSecret
//  - SupportsTwoFactor
func (p *UserStoreClient) Authenticate(username string, password string, consumerKey string, consumerSecret string, supportsTwoFactor bool) (r *AuthenticationResult, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, err error) {
	if err = p.sendAuthenticate(username, password, consumerKey, consumerSecret, supportsTwoFactor); err != nil {
		return
	}
	return p.recvAuthenticate()
}

func (p *UserStoreClient) sendAuthenticate(username string, password string, consumerKey string, consumerSecret string, supportsTwoFactor bool) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("authenticate", thrift.CALL, p.SeqId)
	args9 := NewAuthenticateArgs()
	args9.Username = username
	args9.Password = password
	args9.ConsumerKey = consumerKey
	args9.ConsumerSecret = consumerSecret
	args9.SupportsTwoFactor = supportsTwoFactor
	err = args9.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *UserStoreClient) recvAuthenticate() (value *AuthenticationResult, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error11 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error12 error
		error12, err = error11.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error12
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result10 := NewAuthenticateResult()
	err = result10.Read(iprot)
	iprot.ReadMessageEnd()
	value = result10.Success
	if result10.UserException != nil {
		userException = result10.UserException
	}
	if result10.SystemException != nil {
		systemException = result10.SystemException
	}
	return
}

// This is used to check a username and password in order to create a
// long-lived authentication token that can be used for further actions.
//
// This function is not available to most third party applications,
// which typically authenticate using OAuth as
// described at
// <a href="http://dev.evernote.com/documentation/cloud/">dev.evernote.com</a>.
// If you believe that your application requires permission to authenticate
// using username and password instead of OAuth, please contact Evernote
// developer support by visiting
// <a href="http://dev.evernote.com">dev.evernote.com</a>.
//
// @param username
//   The username or registered email address of the account to
//   authenticate against.
//
// @param password
//   The plaintext password to check against the account.  Since
//   this is not protected by the EDAM protocol, this information must be
//   provided over a protected transport (i.e. SSL).
//
// @param consumerKey
//   The "consumer key" portion of the API key issued to the client application
//   by Evernote.
//
// @param consumerSecret
//   The "consumer secret" portion of the API key issued to the client application
//   by Evernote.
//
// @param deviceIdentifier
//   An optional string, no more than 32 characters in length, that uniquely identifies
//   the device from which the authentication is being performed. This string allows
//   the service to return the same authentication token when a given application
//   requests authentication repeatedly from the same device. This may happen when the
//   user logs out of an application and then logs back in, or when the application is
//   uninstalled and later reinstalled. If no reliable device identifier can be created,
//   this value should be omitted. If set, the device identifier must be between
//   1 and EDAM_DEVICE_ID_LEN_MAX characters long and must match the regular expression
//   EDAM_DEVICE_ID_REGEX.
//
// @param deviceDescription
//   A description of the device from which the authentication is being performed.
//   This field is displayed to the user in a list of authorized applications to
//   allow them to distinguish between multiple tokens issued to the same client
//   application on different devices. For example, the Evernote iOS client on
//   a user's iPhone and iPad might pass the iOS device names "Bob's iPhone" and
//   "Bob's iPad". The device description must be between 1 and
//   EDAM_DEVICE_DESCRIPTION_LEN_MAX characters long and must match the regular
//   expression EDAM_DEVICE_DESCRIPTION_REGEX.
//
// @param supportsTwoFactor
//   Whether the calling application supports two-factor authentication. If this
//   parameter is false, this method will fail with the error code INVALID_AUTH and the
//   parameter "password" when called for a user who has enabled two-factor
//   authentication.
//
// @return
//   <p>The result of the authentication. The level of detail provided in the returned
//   AuthenticationResult.User structure depends on the access level granted by
//   calling application's API key.</p>
//   <p>If the user has two-factor authentication enabled,
//   AuthenticationResult.secondFactorRequired will be set and
//   AuthenticationResult.authenticationToken will contain a short-lived token
//   that may only be used to complete the two-factor authentication process by calling
//   UserStore.completeTwoFactorAuthentication.</p>
//
// @throws EDAMUserException <ul>
//   <li> DATA_REQUIRED "username" - username is empty
//   <li> DATA_REQUIRED "password" - password is empty
//   <li> DATA_REQUIRED "consumerKey" - consumerKey is empty
//   <li> DATA_REQUIRED "consumerSecret" - consumerSecret is empty
//   <li> DATA_REQUIRED "deviceDescription" - deviceDescription is empty
//   <li> BAD_DATA_FORMAT "deviceDescription" - deviceDescription is not valid.
//   <li> BAD_DATA_FORMAT "deviceIdentifier" - deviceIdentifier is not valid.
//   <li> INVALID_AUTH "username" - username not found
//   <li> INVALID_AUTH "password" - password did not match
//   <li> INVALID_AUTH "consumerKey" - consumerKey is not authorized
//   <li> INVALID_AUTH "consumerSecret" - consumerSecret is incorrect
//   <li> PERMISSION_DENIED "User.active" - user account is closed
//   <li> PERMISSION_DENIED "User.tooManyFailuresTryAgainLater" - user has
//     failed authentication too often
// </ul>
//
// Parameters:
//  - Username
//  - Password
//  - ConsumerKey
//  - ConsumerSecret
//  - DeviceIdentifier
//  - DeviceDescription
//  - SupportsTwoFactor
func (p *UserStoreClient) AuthenticateLongSession(username string, password string, consumerKey string, consumerSecret string, deviceIdentifier string, deviceDescription string, supportsTwoFactor bool) (r *AuthenticationResult, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, err error) {
	if err = p.sendAuthenticateLongSession(username, password, consumerKey, consumerSecret, deviceIdentifier, deviceDescription, supportsTwoFactor); err != nil {
		return
	}
	return p.recvAuthenticateLongSession()
}

func (p *UserStoreClient) sendAuthenticateLongSession(username string, password string, consumerKey string, consumerSecret string, deviceIdentifier string, deviceDescription string, supportsTwoFactor bool) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("authenticateLongSession", thrift.CALL, p.SeqId)
	args13 := NewAuthenticateLongSessionArgs()
	args13.Username = username
	args13.Password = password
	args13.ConsumerKey = consumerKey
	args13.ConsumerSecret = consumerSecret
	args13.DeviceIdentifier = deviceIdentifier
	args13.DeviceDescription = deviceDescription
	args13.SupportsTwoFactor = supportsTwoFactor
	err = args13.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *UserStoreClient) recvAuthenticateLongSession() (value *AuthenticationResult, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error15 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error16 error
		error16, err = error15.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error16
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result14 := NewAuthenticateLongSessionResult()
	err = result14.Read(iprot)
	iprot.ReadMessageEnd()
	value = result14.Success
	if result14.UserException != nil {
		userException = result14.UserException
	}
	if result14.SystemException != nil {
		systemException = result14.SystemException
	}
	return
}

// Complete the authentication process when a second factor is required. This
// call is made after a successful call to authenticate or authenticateLongSession
// when the authenticating user has enabled two-factor authentication.
//
// @param authenticationToken An authentication token returned by a previous
//   call to UserStore.authenticate or UserStore.authenticateLongSession that
//   could not be completed in a single call because a second factor was required.
//
// @param oneTimeCode The one time code entered by the user. This value is delivered
//   out-of-band, typically via SMS or an authenticator application.
//
// @param deviceIdentifier See the corresponding parameter in authenticateLongSession.
//
// @param deviceDescription See the corresponding parameter in authenticateLongSession.
//
// @return
//   The result of the authentication. The level of detail provided in the returned
//   AuthenticationResult.User structure depends on the access level granted by the
//   calling application's API key. If the initial authentication call was made to
//   authenticateLongSession, the AuthenticationResult will contain a long-lived
//   authentication token.
//
// @throws EDAMUserException <ul>
//   <li> DATA_REQUIRED "authenticationToken" - authenticationToken is empty
//   <li> DATA_REQUIRED "oneTimeCode" - oneTimeCode is empty
//   <li> BAD_DATA_FORMAT "authenticationToken" - authenticationToken is not well formed
//   <li> INVALID_AUTH "oneTimeCode" - oneTimeCode did not match
//   <li> AUTH_EXPIRED "authenticationToken" - authenticationToken has expired
//   <li> PERMISSION_DENIED "authenticationToken" - authenticationToken is not valid
//   <li> PERMISSION_DENIED "User.active" - user account is closed
//   <li> PERMISSION_DENIED "User.tooManyFailuresTryAgainLater" - user has
//     failed authentication too often
//   <li> DATA_CONFLICT "User.twoFactorAuthentication" - The user has not enabled
//      two-factor authentication.</li>
// </ul>
//
// Parameters:
//  - AuthenticationToken
//  - OneTimeCode
//  - DeviceIdentifier
//  - DeviceDescription
func (p *UserStoreClient) CompleteTwoFactorAuthentication(authenticationToken string, oneTimeCode string, deviceIdentifier string, deviceDescription string) (r *AuthenticationResult, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, err error) {
	if err = p.sendCompleteTwoFactorAuthentication(authenticationToken, oneTimeCode, deviceIdentifier, deviceDescription); err != nil {
		return
	}
	return p.recvCompleteTwoFactorAuthentication()
}

func (p *UserStoreClient) sendCompleteTwoFactorAuthentication(authenticationToken string, oneTimeCode string, deviceIdentifier string, deviceDescription string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("completeTwoFactorAuthentication", thrift.CALL, p.SeqId)
	args17 := NewCompleteTwoFactorAuthenticationArgs()
	args17.AuthenticationToken = authenticationToken
	args17.OneTimeCode = oneTimeCode
	args17.DeviceIdentifier = deviceIdentifier
	args17.DeviceDescription = deviceDescription
	err = args17.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *UserStoreClient) recvCompleteTwoFactorAuthentication() (value *AuthenticationResult, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error19 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error20 error
		error20, err = error19.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error20
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result18 := NewCompleteTwoFactorAuthenticationResult()
	err = result18.Read(iprot)
	iprot.ReadMessageEnd()
	value = result18.Success
	if result18.UserException != nil {
		userException = result18.UserException
	}
	if result18.SystemException != nil {
		systemException = result18.SystemException
	}
	return
}

// Revoke an existing long lived authentication token. This can be used to
// revoke OAuth tokens or tokens created by calling authenticateLongSession,
// and allows a user to effectively log out of Evernote from the perspective
// of the application that holds the token. The authentication token that is
// passed is immediately revoked and may not be used to call any authenticated
// EDAM function.
//
// @param authenticationToken the authentication token to revoke.
//
// @throws EDAMUserException <ul>
//   <li> DATA_REQUIRED "authenticationToken" - no authentication token provided
//   <li> BAD_DATA_FORMAT "authenticationToken" - the authentication token is not well formed
//   <li> INVALID_AUTH "authenticationToken" - the authentication token is invalid
//   <li> AUTH_EXPIRED "authenticationToken" - the authentication token is expired or
//     is already revoked.
// </ul>
//
// Parameters:
//  - AuthenticationToken
func (p *UserStoreClient) RevokeLongSession(authenticationToken string) (userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, err error) {
	if err = p.sendRevokeLongSession(authenticationToken); err != nil {
		return
	}
	return p.recvRevokeLongSession()
}

func (p *UserStoreClient) sendRevokeLongSession(authenticationToken string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("revokeLongSession", thrift.CALL, p.SeqId)
	args21 := NewRevokeLongSessionArgs()
	args21.AuthenticationToken = authenticationToken
	err = args21.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *UserStoreClient) recvRevokeLongSession() (userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error23 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error24 error
		error24, err = error23.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error24
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result22 := NewRevokeLongSessionResult()
	err = result22.Read(iprot)
	iprot.ReadMessageEnd()
	if result22.UserException != nil {
		userException = result22.UserException
	}
	if result22.SystemException != nil {
		systemException = result22.SystemException
	}
	return
}

// This is used to take an existing authentication token that grants access
// to an individual user account (returned from 'authenticate',
// 'authenticateLongSession' or an OAuth authorization) and obtain an additional
// authentication token that may be used to access business notebooks if the user
// is a member of an Evernote Business account.
//
// The resulting authentication token may be used to make NoteStore API calls
// against the business using the NoteStore URL returned in the result.
//
// @param authenticationToken
//   The authentication token for the user. This may not be a shared authentication
//   token (returned by NoteStore.authenticateToSharedNotebook or
//   NoteStore.authenticateToSharedNote) or a business authentication token.
//
// @return
//   The result of the authentication, with the token granting access to the
//   business in the result's 'authenticationToken' field. The URL that must
//   be used to access the business account NoteStore will be returned in the
//   result's 'noteStoreUrl' field.  The 'User' field will
//   not be set in the result.
//
// @throws EDAMUserException <ul>
//   <li> PERMISSION_DENIED "authenticationToken" - the provided authentication token
//        is a shared or business authentication token. </li>
//   <li> PERMISSION_DENIED "Business" - the user identified by the provided
//        authentication token is not currently a member of a business. </li>
//   <li> PERMISSION_DENIED "Business.status" - the business that the user is a
//        member of is not currently in an active status. </li>
// </ul>
//
// Parameters:
//  - AuthenticationToken
func (p *UserStoreClient) AuthenticateToBusiness(authenticationToken string) (r *AuthenticationResult, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, err error) {
	if err = p.sendAuthenticateToBusiness(authenticationToken); err != nil {
		return
	}
	return p.recvAuthenticateToBusiness()
}

func (p *UserStoreClient) sendAuthenticateToBusiness(authenticationToken string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("authenticateToBusiness", thrift.CALL, p.SeqId)
	args25 := NewAuthenticateToBusinessArgs()
	args25.AuthenticationToken = authenticationToken
	err = args25.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *UserStoreClient) recvAuthenticateToBusiness() (value *AuthenticationResult, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error27 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error28 error
		error28, err = error27.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error28
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result26 := NewAuthenticateToBusinessResult()
	err = result26.Read(iprot)
	iprot.ReadMessageEnd()
	value = result26.Success
	if result26.UserException != nil {
		userException = result26.UserException
	}
	if result26.SystemException != nil {
		systemException = result26.SystemException
	}
	return
}

// This is used to take an existing authentication token (returned from
// 'authenticate') and exchange it for a newer token which will not expire
// as soon.  This must be invoked before the previous token expires.
//
// This function is only availabe to Evernote's internal applications.
//
// @param authenticationToken
//   The previous authentication token from the authenticate() result.
//
// @return
//   The result of the authentication, with the new token in
//   the result's 'authenticationToken' field.  The 'User' field will
//   not be set in the result.
//
// Parameters:
//  - AuthenticationToken
func (p *UserStoreClient) RefreshAuthentication(authenticationToken string) (r *AuthenticationResult, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, err error) {
	if err = p.sendRefreshAuthentication(authenticationToken); err != nil {
		return
	}
	return p.recvRefreshAuthentication()
}

func (p *UserStoreClient) sendRefreshAuthentication(authenticationToken string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("refreshAuthentication", thrift.CALL, p.SeqId)
	args29 := NewRefreshAuthenticationArgs()
	args29.AuthenticationToken = authenticationToken
	err = args29.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *UserStoreClient) recvRefreshAuthentication() (value *AuthenticationResult, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error31 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error32 error
		error32, err = error31.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error32
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result30 := NewRefreshAuthenticationResult()
	err = result30.Read(iprot)
	iprot.ReadMessageEnd()
	value = result30.Success
	if result30.UserException != nil {
		userException = result30.UserException
	}
	if result30.SystemException != nil {
		systemException = result30.SystemException
	}
	return
}

// Returns the User corresponding to the provided authentication token,
// or throws an exception if this token is not valid.
// The level of detail provided in the returned User structure depends on
// the access level granted by the token, so a web service client may receive
// fewer fields than an integrated desktop client.
//
// Parameters:
//  - AuthenticationToken
func (p *UserStoreClient) GetUser(authenticationToken string) (r *Types.User, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, err error) {
	if err = p.sendGetUser(authenticationToken); err != nil {
		return
	}
	return p.recvGetUser()
}

func (p *UserStoreClient) sendGetUser(authenticationToken string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("getUser", thrift.CALL, p.SeqId)
	args33 := NewGetUserArgs()
	args33.AuthenticationToken = authenticationToken
	err = args33.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *UserStoreClient) recvGetUser() (value *Types.User, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error35 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error36 error
		error36, err = error35.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error36
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result34 := NewGetUserResult()
	err = result34.Read(iprot)
	iprot.ReadMessageEnd()
	value = result34.Success
	if result34.UserException != nil {
		userException = result34.UserException
	}
	if result34.SystemException != nil {
		systemException = result34.SystemException
	}
	return
}

// Asks the UserStore about the publicly available location information for
// a particular username.
//
// @throws EDAMUserException <ul>
//   <li> DATA_REQUIRED "username" - username is empty
// </ul>
//
// Parameters:
//  - Username
func (p *UserStoreClient) GetPublicUserInfo(username string) (r *PublicUserInfo, notFoundException *Errors.EDAMNotFoundException, systemException *Errors.EDAMSystemException, userException *Errors.EDAMUserException, err error) {
	if err = p.sendGetPublicUserInfo(username); err != nil {
		return
	}
	return p.recvGetPublicUserInfo()
}

func (p *UserStoreClient) sendGetPublicUserInfo(username string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("getPublicUserInfo", thrift.CALL, p.SeqId)
	args37 := NewGetPublicUserInfoArgs()
	args37.Username = username
	err = args37.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *UserStoreClient) recvGetPublicUserInfo() (value *PublicUserInfo, notFoundException *Errors.EDAMNotFoundException, systemException *Errors.EDAMSystemException, userException *Errors.EDAMUserException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error39 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error40 error
		error40, err = error39.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error40
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result38 := NewGetPublicUserInfoResult()
	err = result38.Read(iprot)
	iprot.ReadMessageEnd()
	value = result38.Success
	if result38.NotFoundException != nil {
		notFoundException = result38.NotFoundException
	}
	if result38.SystemException != nil {
		systemException = result38.SystemException
	}
	if result38.UserException != nil {
		userException = result38.UserException
	}
	return
}

// Returns information regarding a user's Premium account corresponding to the
// provided authentication token, or throws an exception if this token is not
// valid.
//
// Parameters:
//  - AuthenticationToken
func (p *UserStoreClient) GetPremiumInfo(authenticationToken string) (r *Types.PremiumInfo, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, err error) {
	if err = p.sendGetPremiumInfo(authenticationToken); err != nil {
		return
	}
	return p.recvGetPremiumInfo()
}

func (p *UserStoreClient) sendGetPremiumInfo(authenticationToken string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("getPremiumInfo", thrift.CALL, p.SeqId)
	args41 := NewGetPremiumInfoArgs()
	args41.AuthenticationToken = authenticationToken
	err = args41.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *UserStoreClient) recvGetPremiumInfo() (value *Types.PremiumInfo, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error43 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error44 error
		error44, err = error43.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error44
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result42 := NewGetPremiumInfoResult()
	err = result42.Read(iprot)
	iprot.ReadMessageEnd()
	value = result42.Success
	if result42.UserException != nil {
		userException = result42.UserException
	}
	if result42.SystemException != nil {
		systemException = result42.SystemException
	}
	return
}

// Returns the URL that should be used to talk to the NoteStore for the
// account represented by the provided authenticationToken.
// This method isn't needed by most clients, who can retrieve the correct
// NoteStore URL from the AuthenticationResult returned from the authenticate
// or refreshAuthentication calls. This method is typically only needed
// to look up the correct URL for a long-lived session token (e.g. for an
// OAuth web service).
//
// Parameters:
//  - AuthenticationToken
func (p *UserStoreClient) GetNoteStoreUrl(authenticationToken string) (r string, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, err error) {
	if err = p.sendGetNoteStoreUrl(authenticationToken); err != nil {
		return
	}
	return p.recvGetNoteStoreUrl()
}

func (p *UserStoreClient) sendGetNoteStoreUrl(authenticationToken string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("getNoteStoreUrl", thrift.CALL, p.SeqId)
	args45 := NewGetNoteStoreUrlArgs()
	args45.AuthenticationToken = authenticationToken
	err = args45.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *UserStoreClient) recvGetNoteStoreUrl() (value string, userException *Errors.EDAMUserException, systemException *Errors.EDAMSystemException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error47 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error48 error
		error48, err = error47.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error48
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result46 := NewGetNoteStoreUrlResult()
	err = result46.Read(iprot)
	iprot.ReadMessageEnd()
	value = result46.Success
	if result46.UserException != nil {
		userException = result46.UserException
	}
	if result46.SystemException != nil {
		systemException = result46.SystemException
	}
	return
}

type UserStoreProcessor struct {
	processorMap map[string]thrift.TProcessorFunction
	handler      UserStore
}

func (p *UserStoreProcessor) AddToProcessorMap(key string, processor thrift.TProcessorFunction) {
	p.processorMap[key] = processor
}

func (p *UserStoreProcessor) GetProcessorFunction(key string) (processor thrift.TProcessorFunction, ok bool) {
	processor, ok = p.processorMap[key]
	return processor, ok
}

func (p *UserStoreProcessor) ProcessorMap() map[string]thrift.TProcessorFunction {
	return p.processorMap
}

func NewUserStoreProcessor(handler UserStore) *UserStoreProcessor {

	self49 := &UserStoreProcessor{handler: handler, processorMap: make(map[string]thrift.TProcessorFunction)}
	self49.processorMap["checkVersion"] = &userStoreProcessorCheckVersion{handler: handler}
	self49.processorMap["getBootstrapInfo"] = &userStoreProcessorGetBootstrapInfo{handler: handler}
	self49.processorMap["authenticate"] = &userStoreProcessorAuthenticate{handler: handler}
	self49.processorMap["authenticateLongSession"] = &userStoreProcessorAuthenticateLongSession{handler: handler}
	self49.processorMap["completeTwoFactorAuthentication"] = &userStoreProcessorCompleteTwoFactorAuthentication{handler: handler}
	self49.processorMap["revokeLongSession"] = &userStoreProcessorRevokeLongSession{handler: handler}
	self49.processorMap["authenticateToBusiness"] = &userStoreProcessorAuthenticateToBusiness{handler: handler}
	self49.processorMap["refreshAuthentication"] = &userStoreProcessorRefreshAuthentication{handler: handler}
	self49.processorMap["getUser"] = &userStoreProcessorGetUser{handler: handler}
	self49.processorMap["getPublicUserInfo"] = &userStoreProcessorGetPublicUserInfo{handler: handler}
	self49.processorMap["getPremiumInfo"] = &userStoreProcessorGetPremiumInfo{handler: handler}
	self49.processorMap["getNoteStoreUrl"] = &userStoreProcessorGetNoteStoreUrl{handler: handler}
	return self49
}

func (p *UserStoreProcessor) Process(iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	name, _, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return false, err
	}
	if processor, ok := p.GetProcessorFunction(name); ok {
		return processor.Process(seqId, iprot, oprot)
	}
	iprot.Skip(thrift.STRUCT)
	iprot.ReadMessageEnd()
	x50 := thrift.NewTApplicationException(thrift.UNKNOWN_METHOD, "Unknown function "+name)
	oprot.WriteMessageBegin(name, thrift.EXCEPTION, seqId)
	x50.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return false, x50

}

type userStoreProcessorCheckVersion struct {
	handler UserStore
}

func (p *userStoreProcessorCheckVersion) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewCheckVersionArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("checkVersion", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewCheckVersionResult()
	if result.Success, err = p.handler.CheckVersion(args.ClientName, args.EdamVersionMajor, args.EdamVersionMinor); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing checkVersion: "+err.Error())
		oprot.WriteMessageBegin("checkVersion", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("checkVersion", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type userStoreProcessorGetBootstrapInfo struct {
	handler UserStore
}

func (p *userStoreProcessorGetBootstrapInfo) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewGetBootstrapInfoArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getBootstrapInfo", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewGetBootstrapInfoResult()
	if result.Success, err = p.handler.GetBootstrapInfo(args.Locale); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getBootstrapInfo: "+err.Error())
		oprot.WriteMessageBegin("getBootstrapInfo", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("getBootstrapInfo", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type userStoreProcessorAuthenticate struct {
	handler UserStore
}

func (p *userStoreProcessorAuthenticate) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewAuthenticateArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("authenticate", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewAuthenticateResult()
	if result.Success, result.UserException, result.SystemException, err = p.handler.Authenticate(args.Username, args.Password, args.ConsumerKey, args.ConsumerSecret, args.SupportsTwoFactor); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing authenticate: "+err.Error())
		oprot.WriteMessageBegin("authenticate", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("authenticate", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type userStoreProcessorAuthenticateLongSession struct {
	handler UserStore
}

func (p *userStoreProcessorAuthenticateLongSession) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewAuthenticateLongSessionArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("authenticateLongSession", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewAuthenticateLongSessionResult()
	if result.Success, result.UserException, result.SystemException, err = p.handler.AuthenticateLongSession(args.Username, args.Password, args.ConsumerKey, args.ConsumerSecret, args.DeviceIdentifier, args.DeviceDescription, args.SupportsTwoFactor); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing authenticateLongSession: "+err.Error())
		oprot.WriteMessageBegin("authenticateLongSession", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("authenticateLongSession", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type userStoreProcessorCompleteTwoFactorAuthentication struct {
	handler UserStore
}

func (p *userStoreProcessorCompleteTwoFactorAuthentication) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewCompleteTwoFactorAuthenticationArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("completeTwoFactorAuthentication", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewCompleteTwoFactorAuthenticationResult()
	if result.Success, result.UserException, result.SystemException, err = p.handler.CompleteTwoFactorAuthentication(args.AuthenticationToken, args.OneTimeCode, args.DeviceIdentifier, args.DeviceDescription); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing completeTwoFactorAuthentication: "+err.Error())
		oprot.WriteMessageBegin("completeTwoFactorAuthentication", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("completeTwoFactorAuthentication", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type userStoreProcessorRevokeLongSession struct {
	handler UserStore
}

func (p *userStoreProcessorRevokeLongSession) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewRevokeLongSessionArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("revokeLongSession", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewRevokeLongSessionResult()
	if result.UserException, result.SystemException, err = p.handler.RevokeLongSession(args.AuthenticationToken); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing revokeLongSession: "+err.Error())
		oprot.WriteMessageBegin("revokeLongSession", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("revokeLongSession", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type userStoreProcessorAuthenticateToBusiness struct {
	handler UserStore
}

func (p *userStoreProcessorAuthenticateToBusiness) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewAuthenticateToBusinessArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("authenticateToBusiness", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewAuthenticateToBusinessResult()
	if result.Success, result.UserException, result.SystemException, err = p.handler.AuthenticateToBusiness(args.AuthenticationToken); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing authenticateToBusiness: "+err.Error())
		oprot.WriteMessageBegin("authenticateToBusiness", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("authenticateToBusiness", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type userStoreProcessorRefreshAuthentication struct {
	handler UserStore
}

func (p *userStoreProcessorRefreshAuthentication) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewRefreshAuthenticationArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("refreshAuthentication", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewRefreshAuthenticationResult()
	if result.Success, result.UserException, result.SystemException, err = p.handler.RefreshAuthentication(args.AuthenticationToken); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing refreshAuthentication: "+err.Error())
		oprot.WriteMessageBegin("refreshAuthentication", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("refreshAuthentication", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type userStoreProcessorGetUser struct {
	handler UserStore
}

func (p *userStoreProcessorGetUser) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewGetUserArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getUser", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewGetUserResult()
	if result.Success, result.UserException, result.SystemException, err = p.handler.GetUser(args.AuthenticationToken); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getUser: "+err.Error())
		oprot.WriteMessageBegin("getUser", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("getUser", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type userStoreProcessorGetPublicUserInfo struct {
	handler UserStore
}

func (p *userStoreProcessorGetPublicUserInfo) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewGetPublicUserInfoArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getPublicUserInfo", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewGetPublicUserInfoResult()
	if result.Success, result.NotFoundException, result.SystemException, result.UserException, err = p.handler.GetPublicUserInfo(args.Username); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getPublicUserInfo: "+err.Error())
		oprot.WriteMessageBegin("getPublicUserInfo", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("getPublicUserInfo", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type userStoreProcessorGetPremiumInfo struct {
	handler UserStore
}

func (p *userStoreProcessorGetPremiumInfo) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewGetPremiumInfoArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getPremiumInfo", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewGetPremiumInfoResult()
	if result.Success, result.UserException, result.SystemException, err = p.handler.GetPremiumInfo(args.AuthenticationToken); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getPremiumInfo: "+err.Error())
		oprot.WriteMessageBegin("getPremiumInfo", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("getPremiumInfo", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type userStoreProcessorGetNoteStoreUrl struct {
	handler UserStore
}

func (p *userStoreProcessorGetNoteStoreUrl) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewGetNoteStoreUrlArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getNoteStoreUrl", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewGetNoteStoreUrlResult()
	if result.Success, result.UserException, result.SystemException, err = p.handler.GetNoteStoreUrl(args.AuthenticationToken); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getNoteStoreUrl: "+err.Error())
		oprot.WriteMessageBegin("getNoteStoreUrl", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("getNoteStoreUrl", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

// HELPER FUNCTIONS AND STRUCTURES

type CheckVersionArgs struct {
	ClientName       string `thrift:"clientName,1"`
	EdamVersionMajor int16  `thrift:"edamVersionMajor,2"`
	EdamVersionMinor int16  `thrift:"edamVersionMinor,3"`
}

func NewCheckVersionArgs() *CheckVersionArgs {
	return &CheckVersionArgs{
		EdamVersionMajor: 1,

		EdamVersionMinor: 25,
	}
}

func (p *CheckVersionArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CheckVersionArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.ClientName = v
	}
	return nil
}

func (p *CheckVersionArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI16(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.EdamVersionMajor = v
	}
	return nil
}

func (p *CheckVersionArgs) readField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI16(); err != nil {
		return fmt.Errorf("error reading field 3: %s")
	} else {
		p.EdamVersionMinor = v
	}
	return nil
}

func (p *CheckVersionArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("checkVersion_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *CheckVersionArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("clientName", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:clientName: %s", p, err)
	}
	if err := oprot.WriteString(string(p.ClientName)); err != nil {
		return fmt.Errorf("%T.clientName (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:clientName: %s", p, err)
	}
	return err
}

func (p *CheckVersionArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("edamVersionMajor", thrift.I16, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:edamVersionMajor: %s", p, err)
	}
	if err := oprot.WriteI16(int16(p.EdamVersionMajor)); err != nil {
		return fmt.Errorf("%T.edamVersionMajor (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:edamVersionMajor: %s", p, err)
	}
	return err
}

func (p *CheckVersionArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("edamVersionMinor", thrift.I16, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:edamVersionMinor: %s", p, err)
	}
	if err := oprot.WriteI16(int16(p.EdamVersionMinor)); err != nil {
		return fmt.Errorf("%T.edamVersionMinor (3) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:edamVersionMinor: %s", p, err)
	}
	return err
}

func (p *CheckVersionArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CheckVersionArgs(%+v)", *p)
}

type CheckVersionResult struct {
	Success bool `thrift:"success,0"`
}

func NewCheckVersionResult() *CheckVersionResult {
	return &CheckVersionResult{}
}

func (p *CheckVersionResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CheckVersionResult) readField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(); err != nil {
		return fmt.Errorf("error reading field 0: %s")
	} else {
		p.Success = v
	}
	return nil
}

func (p *CheckVersionResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("checkVersion_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *CheckVersionResult) writeField0(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("success", thrift.BOOL, 0); err != nil {
		return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
	}
	if err := oprot.WriteBool(bool(p.Success)); err != nil {
		return fmt.Errorf("%T.success (0) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 0:success: %s", p, err)
	}
	return err
}

func (p *CheckVersionResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CheckVersionResult(%+v)", *p)
}

type GetBootstrapInfoArgs struct {
	Locale string `thrift:"locale,1"`
}

func NewGetBootstrapInfoArgs() *GetBootstrapInfoArgs {
	return &GetBootstrapInfoArgs{}
}

func (p *GetBootstrapInfoArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetBootstrapInfoArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Locale = v
	}
	return nil
}

func (p *GetBootstrapInfoArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getBootstrapInfo_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetBootstrapInfoArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("locale", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:locale: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Locale)); err != nil {
		return fmt.Errorf("%T.locale (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:locale: %s", p, err)
	}
	return err
}

func (p *GetBootstrapInfoArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetBootstrapInfoArgs(%+v)", *p)
}

type GetBootstrapInfoResult struct {
	Success *BootstrapInfo `thrift:"success,0"`
}

func NewGetBootstrapInfoResult() *GetBootstrapInfoResult {
	return &GetBootstrapInfoResult{}
}

func (p *GetBootstrapInfoResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetBootstrapInfoResult) readField0(iprot thrift.TProtocol) error {
	p.Success = NewBootstrapInfo()
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success)
	}
	return nil
}

func (p *GetBootstrapInfoResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getBootstrapInfo_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetBootstrapInfoResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetBootstrapInfoResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetBootstrapInfoResult(%+v)", *p)
}

type AuthenticateArgs struct {
	Username          string `thrift:"username,1"`
	Password          string `thrift:"password,2"`
	ConsumerKey       string `thrift:"consumerKey,3"`
	ConsumerSecret    string `thrift:"consumerSecret,4"`
	SupportsTwoFactor bool   `thrift:"supportsTwoFactor,5"`
}

func NewAuthenticateArgs() *AuthenticateArgs {
	return &AuthenticateArgs{}
}

func (p *AuthenticateArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		case 5:
			if err := p.readField5(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *AuthenticateArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Username = v
	}
	return nil
}

func (p *AuthenticateArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.Password = v
	}
	return nil
}

func (p *AuthenticateArgs) readField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 3: %s")
	} else {
		p.ConsumerKey = v
	}
	return nil
}

func (p *AuthenticateArgs) readField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 4: %s")
	} else {
		p.ConsumerSecret = v
	}
	return nil
}

func (p *AuthenticateArgs) readField5(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(); err != nil {
		return fmt.Errorf("error reading field 5: %s")
	} else {
		p.SupportsTwoFactor = v
	}
	return nil
}

func (p *AuthenticateArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("authenticate_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := p.writeField5(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *AuthenticateArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("username", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:username: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Username)); err != nil {
		return fmt.Errorf("%T.username (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:username: %s", p, err)
	}
	return err
}

func (p *AuthenticateArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("password", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:password: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Password)); err != nil {
		return fmt.Errorf("%T.password (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:password: %s", p, err)
	}
	return err
}

func (p *AuthenticateArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("consumerKey", thrift.STRING, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:consumerKey: %s", p, err)
	}
	if err := oprot.WriteString(string(p.ConsumerKey)); err != nil {
		return fmt.Errorf("%T.consumerKey (3) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:consumerKey: %s", p, err)
	}
	return err
}

func (p *AuthenticateArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("consumerSecret", thrift.STRING, 4); err != nil {
		return fmt.Errorf("%T write field begin error 4:consumerSecret: %s", p, err)
	}
	if err := oprot.WriteString(string(p.ConsumerSecret)); err != nil {
		return fmt.Errorf("%T.consumerSecret (4) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 4:consumerSecret: %s", p, err)
	}
	return err
}

func (p *AuthenticateArgs) writeField5(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("supportsTwoFactor", thrift.BOOL, 5); err != nil {
		return fmt.Errorf("%T write field begin error 5:supportsTwoFactor: %s", p, err)
	}
	if err := oprot.WriteBool(bool(p.SupportsTwoFactor)); err != nil {
		return fmt.Errorf("%T.supportsTwoFactor (5) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 5:supportsTwoFactor: %s", p, err)
	}
	return err
}

func (p *AuthenticateArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("AuthenticateArgs(%+v)", *p)
}

type AuthenticateResult struct {
	Success         *AuthenticationResult       `thrift:"success,0"`
	UserException   *Errors.EDAMUserException   `thrift:"userException,1"`
	SystemException *Errors.EDAMSystemException `thrift:"systemException,2"`
}

func NewAuthenticateResult() *AuthenticateResult {
	return &AuthenticateResult{}
}

func (p *AuthenticateResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *AuthenticateResult) readField0(iprot thrift.TProtocol) error {
	p.Success = NewAuthenticationResult()
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success)
	}
	return nil
}

func (p *AuthenticateResult) readField1(iprot thrift.TProtocol) error {
	p.UserException = Errors.NewEDAMUserException()
	if err := p.UserException.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.UserException)
	}
	return nil
}

func (p *AuthenticateResult) readField2(iprot thrift.TProtocol) error {
	p.SystemException = Errors.NewEDAMSystemException()
	if err := p.SystemException.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.SystemException)
	}
	return nil
}

func (p *AuthenticateResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("authenticate_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.SystemException != nil:
		if err := p.writeField2(oprot); err != nil {
			return err
		}
	case p.UserException != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *AuthenticateResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *AuthenticateResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.UserException != nil {
		if err := oprot.WriteFieldBegin("userException", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:userException: %s", p, err)
		}
		if err := p.UserException.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.UserException)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:userException: %s", p, err)
		}
	}
	return err
}

func (p *AuthenticateResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.SystemException != nil {
		if err := oprot.WriteFieldBegin("systemException", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:systemException: %s", p, err)
		}
		if err := p.SystemException.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.SystemException)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:systemException: %s", p, err)
		}
	}
	return err
}

func (p *AuthenticateResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("AuthenticateResult(%+v)", *p)
}

type AuthenticateLongSessionArgs struct {
	Username          string `thrift:"username,1"`
	Password          string `thrift:"password,2"`
	ConsumerKey       string `thrift:"consumerKey,3"`
	ConsumerSecret    string `thrift:"consumerSecret,4"`
	DeviceIdentifier  string `thrift:"deviceIdentifier,5"`
	DeviceDescription string `thrift:"deviceDescription,6"`
	SupportsTwoFactor bool   `thrift:"supportsTwoFactor,7"`
}

func NewAuthenticateLongSessionArgs() *AuthenticateLongSessionArgs {
	return &AuthenticateLongSessionArgs{}
}

func (p *AuthenticateLongSessionArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		case 5:
			if err := p.readField5(iprot); err != nil {
				return err
			}
		case 6:
			if err := p.readField6(iprot); err != nil {
				return err
			}
		case 7:
			if err := p.readField7(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *AuthenticateLongSessionArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Username = v
	}
	return nil
}

func (p *AuthenticateLongSessionArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.Password = v
	}
	return nil
}

func (p *AuthenticateLongSessionArgs) readField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 3: %s")
	} else {
		p.ConsumerKey = v
	}
	return nil
}

func (p *AuthenticateLongSessionArgs) readField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 4: %s")
	} else {
		p.ConsumerSecret = v
	}
	return nil
}

func (p *AuthenticateLongSessionArgs) readField5(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 5: %s")
	} else {
		p.DeviceIdentifier = v
	}
	return nil
}

func (p *AuthenticateLongSessionArgs) readField6(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 6: %s")
	} else {
		p.DeviceDescription = v
	}
	return nil
}

func (p *AuthenticateLongSessionArgs) readField7(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(); err != nil {
		return fmt.Errorf("error reading field 7: %s")
	} else {
		p.SupportsTwoFactor = v
	}
	return nil
}

func (p *AuthenticateLongSessionArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("authenticateLongSession_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := p.writeField5(oprot); err != nil {
		return err
	}
	if err := p.writeField6(oprot); err != nil {
		return err
	}
	if err := p.writeField7(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *AuthenticateLongSessionArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("username", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:username: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Username)); err != nil {
		return fmt.Errorf("%T.username (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:username: %s", p, err)
	}
	return err
}

func (p *AuthenticateLongSessionArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("password", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:password: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Password)); err != nil {
		return fmt.Errorf("%T.password (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:password: %s", p, err)
	}
	return err
}

func (p *AuthenticateLongSessionArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("consumerKey", thrift.STRING, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:consumerKey: %s", p, err)
	}
	if err := oprot.WriteString(string(p.ConsumerKey)); err != nil {
		return fmt.Errorf("%T.consumerKey (3) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:consumerKey: %s", p, err)
	}
	return err
}

func (p *AuthenticateLongSessionArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("consumerSecret", thrift.STRING, 4); err != nil {
		return fmt.Errorf("%T write field begin error 4:consumerSecret: %s", p, err)
	}
	if err := oprot.WriteString(string(p.ConsumerSecret)); err != nil {
		return fmt.Errorf("%T.consumerSecret (4) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 4:consumerSecret: %s", p, err)
	}
	return err
}

func (p *AuthenticateLongSessionArgs) writeField5(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("deviceIdentifier", thrift.STRING, 5); err != nil {
		return fmt.Errorf("%T write field begin error 5:deviceIdentifier: %s", p, err)
	}
	if err := oprot.WriteString(string(p.DeviceIdentifier)); err != nil {
		return fmt.Errorf("%T.deviceIdentifier (5) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 5:deviceIdentifier: %s", p, err)
	}
	return err
}

func (p *AuthenticateLongSessionArgs) writeField6(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("deviceDescription", thrift.STRING, 6); err != nil {
		return fmt.Errorf("%T write field begin error 6:deviceDescription: %s", p, err)
	}
	if err := oprot.WriteString(string(p.DeviceDescription)); err != nil {
		return fmt.Errorf("%T.deviceDescription (6) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 6:deviceDescription: %s", p, err)
	}
	return err
}

func (p *AuthenticateLongSessionArgs) writeField7(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("supportsTwoFactor", thrift.BOOL, 7); err != nil {
		return fmt.Errorf("%T write field begin error 7:supportsTwoFactor: %s", p, err)
	}
	if err := oprot.WriteBool(bool(p.SupportsTwoFactor)); err != nil {
		return fmt.Errorf("%T.supportsTwoFactor (7) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 7:supportsTwoFactor: %s", p, err)
	}
	return err
}

func (p *AuthenticateLongSessionArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("AuthenticateLongSessionArgs(%+v)", *p)
}

type AuthenticateLongSessionResult struct {
	Success         *AuthenticationResult       `thrift:"success,0"`
	UserException   *Errors.EDAMUserException   `thrift:"userException,1"`
	SystemException *Errors.EDAMSystemException `thrift:"systemException,2"`
}

func NewAuthenticateLongSessionResult() *AuthenticateLongSessionResult {
	return &AuthenticateLongSessionResult{}
}

func (p *AuthenticateLongSessionResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *AuthenticateLongSessionResult) readField0(iprot thrift.TProtocol) error {
	p.Success = NewAuthenticationResult()
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success)
	}
	return nil
}

func (p *AuthenticateLongSessionResult) readField1(iprot thrift.TProtocol) error {
	p.UserException = Errors.NewEDAMUserException()
	if err := p.UserException.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.UserException)
	}
	return nil
}

func (p *AuthenticateLongSessionResult) readField2(iprot thrift.TProtocol) error {
	p.SystemException = Errors.NewEDAMSystemException()
	if err := p.SystemException.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.SystemException)
	}
	return nil
}

func (p *AuthenticateLongSessionResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("authenticateLongSession_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.SystemException != nil:
		if err := p.writeField2(oprot); err != nil {
			return err
		}
	case p.UserException != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *AuthenticateLongSessionResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *AuthenticateLongSessionResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.UserException != nil {
		if err := oprot.WriteFieldBegin("userException", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:userException: %s", p, err)
		}
		if err := p.UserException.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.UserException)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:userException: %s", p, err)
		}
	}
	return err
}

func (p *AuthenticateLongSessionResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.SystemException != nil {
		if err := oprot.WriteFieldBegin("systemException", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:systemException: %s", p, err)
		}
		if err := p.SystemException.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.SystemException)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:systemException: %s", p, err)
		}
	}
	return err
}

func (p *AuthenticateLongSessionResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("AuthenticateLongSessionResult(%+v)", *p)
}

type CompleteTwoFactorAuthenticationArgs struct {
	AuthenticationToken string `thrift:"authenticationToken,1"`
	OneTimeCode         string `thrift:"oneTimeCode,2"`
	DeviceIdentifier    string `thrift:"deviceIdentifier,3"`
	DeviceDescription   string `thrift:"deviceDescription,4"`
}

func NewCompleteTwoFactorAuthenticationArgs() *CompleteTwoFactorAuthenticationArgs {
	return &CompleteTwoFactorAuthenticationArgs{}
}

func (p *CompleteTwoFactorAuthenticationArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CompleteTwoFactorAuthenticationArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.AuthenticationToken = v
	}
	return nil
}

func (p *CompleteTwoFactorAuthenticationArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.OneTimeCode = v
	}
	return nil
}

func (p *CompleteTwoFactorAuthenticationArgs) readField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 3: %s")
	} else {
		p.DeviceIdentifier = v
	}
	return nil
}

func (p *CompleteTwoFactorAuthenticationArgs) readField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 4: %s")
	} else {
		p.DeviceDescription = v
	}
	return nil
}

func (p *CompleteTwoFactorAuthenticationArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("completeTwoFactorAuthentication_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *CompleteTwoFactorAuthenticationArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("authenticationToken", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:authenticationToken: %s", p, err)
	}
	if err := oprot.WriteString(string(p.AuthenticationToken)); err != nil {
		return fmt.Errorf("%T.authenticationToken (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:authenticationToken: %s", p, err)
	}
	return err
}

func (p *CompleteTwoFactorAuthenticationArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("oneTimeCode", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:oneTimeCode: %s", p, err)
	}
	if err := oprot.WriteString(string(p.OneTimeCode)); err != nil {
		return fmt.Errorf("%T.oneTimeCode (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:oneTimeCode: %s", p, err)
	}
	return err
}

func (p *CompleteTwoFactorAuthenticationArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("deviceIdentifier", thrift.STRING, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:deviceIdentifier: %s", p, err)
	}
	if err := oprot.WriteString(string(p.DeviceIdentifier)); err != nil {
		return fmt.Errorf("%T.deviceIdentifier (3) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:deviceIdentifier: %s", p, err)
	}
	return err
}

func (p *CompleteTwoFactorAuthenticationArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("deviceDescription", thrift.STRING, 4); err != nil {
		return fmt.Errorf("%T write field begin error 4:deviceDescription: %s", p, err)
	}
	if err := oprot.WriteString(string(p.DeviceDescription)); err != nil {
		return fmt.Errorf("%T.deviceDescription (4) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 4:deviceDescription: %s", p, err)
	}
	return err
}

func (p *CompleteTwoFactorAuthenticationArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CompleteTwoFactorAuthenticationArgs(%+v)", *p)
}

type CompleteTwoFactorAuthenticationResult struct {
	Success         *AuthenticationResult       `thrift:"success,0"`
	UserException   *Errors.EDAMUserException   `thrift:"userException,1"`
	SystemException *Errors.EDAMSystemException `thrift:"systemException,2"`
}

func NewCompleteTwoFactorAuthenticationResult() *CompleteTwoFactorAuthenticationResult {
	return &CompleteTwoFactorAuthenticationResult{}
}

func (p *CompleteTwoFactorAuthenticationResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CompleteTwoFactorAuthenticationResult) readField0(iprot thrift.TProtocol) error {
	p.Success = NewAuthenticationResult()
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success)
	}
	return nil
}

func (p *CompleteTwoFactorAuthenticationResult) readField1(iprot thrift.TProtocol) error {
	p.UserException = Errors.NewEDAMUserException()
	if err := p.UserException.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.UserException)
	}
	return nil
}

func (p *CompleteTwoFactorAuthenticationResult) readField2(iprot thrift.TProtocol) error {
	p.SystemException = Errors.NewEDAMSystemException()
	if err := p.SystemException.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.SystemException)
	}
	return nil
}

func (p *CompleteTwoFactorAuthenticationResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("completeTwoFactorAuthentication_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.SystemException != nil:
		if err := p.writeField2(oprot); err != nil {
			return err
		}
	case p.UserException != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *CompleteTwoFactorAuthenticationResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *CompleteTwoFactorAuthenticationResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.UserException != nil {
		if err := oprot.WriteFieldBegin("userException", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:userException: %s", p, err)
		}
		if err := p.UserException.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.UserException)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:userException: %s", p, err)
		}
	}
	return err
}

func (p *CompleteTwoFactorAuthenticationResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.SystemException != nil {
		if err := oprot.WriteFieldBegin("systemException", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:systemException: %s", p, err)
		}
		if err := p.SystemException.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.SystemException)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:systemException: %s", p, err)
		}
	}
	return err
}

func (p *CompleteTwoFactorAuthenticationResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CompleteTwoFactorAuthenticationResult(%+v)", *p)
}

type RevokeLongSessionArgs struct {
	AuthenticationToken string `thrift:"authenticationToken,1"`
}

func NewRevokeLongSessionArgs() *RevokeLongSessionArgs {
	return &RevokeLongSessionArgs{}
}

func (p *RevokeLongSessionArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *RevokeLongSessionArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.AuthenticationToken = v
	}
	return nil
}

func (p *RevokeLongSessionArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("revokeLongSession_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *RevokeLongSessionArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("authenticationToken", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:authenticationToken: %s", p, err)
	}
	if err := oprot.WriteString(string(p.AuthenticationToken)); err != nil {
		return fmt.Errorf("%T.authenticationToken (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:authenticationToken: %s", p, err)
	}
	return err
}

func (p *RevokeLongSessionArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("RevokeLongSessionArgs(%+v)", *p)
}

type RevokeLongSessionResult struct {
	UserException   *Errors.EDAMUserException   `thrift:"userException,1"`
	SystemException *Errors.EDAMSystemException `thrift:"systemException,2"`
}

func NewRevokeLongSessionResult() *RevokeLongSessionResult {
	return &RevokeLongSessionResult{}
}

func (p *RevokeLongSessionResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *RevokeLongSessionResult) readField1(iprot thrift.TProtocol) error {
	p.UserException = Errors.NewEDAMUserException()
	if err := p.UserException.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.UserException)
	}
	return nil
}

func (p *RevokeLongSessionResult) readField2(iprot thrift.TProtocol) error {
	p.SystemException = Errors.NewEDAMSystemException()
	if err := p.SystemException.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.SystemException)
	}
	return nil
}

func (p *RevokeLongSessionResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("revokeLongSession_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.SystemException != nil:
		if err := p.writeField2(oprot); err != nil {
			return err
		}
	case p.UserException != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *RevokeLongSessionResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.UserException != nil {
		if err := oprot.WriteFieldBegin("userException", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:userException: %s", p, err)
		}
		if err := p.UserException.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.UserException)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:userException: %s", p, err)
		}
	}
	return err
}

func (p *RevokeLongSessionResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.SystemException != nil {
		if err := oprot.WriteFieldBegin("systemException", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:systemException: %s", p, err)
		}
		if err := p.SystemException.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.SystemException)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:systemException: %s", p, err)
		}
	}
	return err
}

func (p *RevokeLongSessionResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("RevokeLongSessionResult(%+v)", *p)
}

type AuthenticateToBusinessArgs struct {
	AuthenticationToken string `thrift:"authenticationToken,1"`
}

func NewAuthenticateToBusinessArgs() *AuthenticateToBusinessArgs {
	return &AuthenticateToBusinessArgs{}
}

func (p *AuthenticateToBusinessArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *AuthenticateToBusinessArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.AuthenticationToken = v
	}
	return nil
}

func (p *AuthenticateToBusinessArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("authenticateToBusiness_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *AuthenticateToBusinessArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("authenticationToken", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:authenticationToken: %s", p, err)
	}
	if err := oprot.WriteString(string(p.AuthenticationToken)); err != nil {
		return fmt.Errorf("%T.authenticationToken (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:authenticationToken: %s", p, err)
	}
	return err
}

func (p *AuthenticateToBusinessArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("AuthenticateToBusinessArgs(%+v)", *p)
}

type AuthenticateToBusinessResult struct {
	Success         *AuthenticationResult       `thrift:"success,0"`
	UserException   *Errors.EDAMUserException   `thrift:"userException,1"`
	SystemException *Errors.EDAMSystemException `thrift:"systemException,2"`
}

func NewAuthenticateToBusinessResult() *AuthenticateToBusinessResult {
	return &AuthenticateToBusinessResult{}
}

func (p *AuthenticateToBusinessResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *AuthenticateToBusinessResult) readField0(iprot thrift.TProtocol) error {
	p.Success = NewAuthenticationResult()
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success)
	}
	return nil
}

func (p *AuthenticateToBusinessResult) readField1(iprot thrift.TProtocol) error {
	p.UserException = Errors.NewEDAMUserException()
	if err := p.UserException.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.UserException)
	}
	return nil
}

func (p *AuthenticateToBusinessResult) readField2(iprot thrift.TProtocol) error {
	p.SystemException = Errors.NewEDAMSystemException()
	if err := p.SystemException.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.SystemException)
	}
	return nil
}

func (p *AuthenticateToBusinessResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("authenticateToBusiness_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.SystemException != nil:
		if err := p.writeField2(oprot); err != nil {
			return err
		}
	case p.UserException != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *AuthenticateToBusinessResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *AuthenticateToBusinessResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.UserException != nil {
		if err := oprot.WriteFieldBegin("userException", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:userException: %s", p, err)
		}
		if err := p.UserException.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.UserException)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:userException: %s", p, err)
		}
	}
	return err
}

func (p *AuthenticateToBusinessResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.SystemException != nil {
		if err := oprot.WriteFieldBegin("systemException", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:systemException: %s", p, err)
		}
		if err := p.SystemException.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.SystemException)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:systemException: %s", p, err)
		}
	}
	return err
}

func (p *AuthenticateToBusinessResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("AuthenticateToBusinessResult(%+v)", *p)
}

type RefreshAuthenticationArgs struct {
	AuthenticationToken string `thrift:"authenticationToken,1"`
}

func NewRefreshAuthenticationArgs() *RefreshAuthenticationArgs {
	return &RefreshAuthenticationArgs{}
}

func (p *RefreshAuthenticationArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *RefreshAuthenticationArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.AuthenticationToken = v
	}
	return nil
}

func (p *RefreshAuthenticationArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("refreshAuthentication_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *RefreshAuthenticationArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("authenticationToken", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:authenticationToken: %s", p, err)
	}
	if err := oprot.WriteString(string(p.AuthenticationToken)); err != nil {
		return fmt.Errorf("%T.authenticationToken (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:authenticationToken: %s", p, err)
	}
	return err
}

func (p *RefreshAuthenticationArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("RefreshAuthenticationArgs(%+v)", *p)
}

type RefreshAuthenticationResult struct {
	Success         *AuthenticationResult       `thrift:"success,0"`
	UserException   *Errors.EDAMUserException   `thrift:"userException,1"`
	SystemException *Errors.EDAMSystemException `thrift:"systemException,2"`
}

func NewRefreshAuthenticationResult() *RefreshAuthenticationResult {
	return &RefreshAuthenticationResult{}
}

func (p *RefreshAuthenticationResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *RefreshAuthenticationResult) readField0(iprot thrift.TProtocol) error {
	p.Success = NewAuthenticationResult()
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success)
	}
	return nil
}

func (p *RefreshAuthenticationResult) readField1(iprot thrift.TProtocol) error {
	p.UserException = Errors.NewEDAMUserException()
	if err := p.UserException.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.UserException)
	}
	return nil
}

func (p *RefreshAuthenticationResult) readField2(iprot thrift.TProtocol) error {
	p.SystemException = Errors.NewEDAMSystemException()
	if err := p.SystemException.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.SystemException)
	}
	return nil
}

func (p *RefreshAuthenticationResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("refreshAuthentication_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.SystemException != nil:
		if err := p.writeField2(oprot); err != nil {
			return err
		}
	case p.UserException != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *RefreshAuthenticationResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *RefreshAuthenticationResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.UserException != nil {
		if err := oprot.WriteFieldBegin("userException", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:userException: %s", p, err)
		}
		if err := p.UserException.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.UserException)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:userException: %s", p, err)
		}
	}
	return err
}

func (p *RefreshAuthenticationResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.SystemException != nil {
		if err := oprot.WriteFieldBegin("systemException", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:systemException: %s", p, err)
		}
		if err := p.SystemException.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.SystemException)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:systemException: %s", p, err)
		}
	}
	return err
}

func (p *RefreshAuthenticationResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("RefreshAuthenticationResult(%+v)", *p)
}

type GetUserArgs struct {
	AuthenticationToken string `thrift:"authenticationToken,1"`
}

func NewGetUserArgs() *GetUserArgs {
	return &GetUserArgs{}
}

func (p *GetUserArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetUserArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.AuthenticationToken = v
	}
	return nil
}

func (p *GetUserArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getUser_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetUserArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("authenticationToken", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:authenticationToken: %s", p, err)
	}
	if err := oprot.WriteString(string(p.AuthenticationToken)); err != nil {
		return fmt.Errorf("%T.authenticationToken (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:authenticationToken: %s", p, err)
	}
	return err
}

func (p *GetUserArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetUserArgs(%+v)", *p)
}

type GetUserResult struct {
	Success         *Types.User                 `thrift:"success,0"`
	UserException   *Errors.EDAMUserException   `thrift:"userException,1"`
	SystemException *Errors.EDAMSystemException `thrift:"systemException,2"`
}

func NewGetUserResult() *GetUserResult {
	return &GetUserResult{}
}

func (p *GetUserResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetUserResult) readField0(iprot thrift.TProtocol) error {
	p.Success = Types.NewUser()
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success)
	}
	return nil
}

func (p *GetUserResult) readField1(iprot thrift.TProtocol) error {
	p.UserException = Errors.NewEDAMUserException()
	if err := p.UserException.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.UserException)
	}
	return nil
}

func (p *GetUserResult) readField2(iprot thrift.TProtocol) error {
	p.SystemException = Errors.NewEDAMSystemException()
	if err := p.SystemException.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.SystemException)
	}
	return nil
}

func (p *GetUserResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getUser_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.SystemException != nil:
		if err := p.writeField2(oprot); err != nil {
			return err
		}
	case p.UserException != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetUserResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetUserResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.UserException != nil {
		if err := oprot.WriteFieldBegin("userException", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:userException: %s", p, err)
		}
		if err := p.UserException.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.UserException)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:userException: %s", p, err)
		}
	}
	return err
}

func (p *GetUserResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.SystemException != nil {
		if err := oprot.WriteFieldBegin("systemException", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:systemException: %s", p, err)
		}
		if err := p.SystemException.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.SystemException)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:systemException: %s", p, err)
		}
	}
	return err
}

func (p *GetUserResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetUserResult(%+v)", *p)
}

type GetPublicUserInfoArgs struct {
	Username string `thrift:"username,1"`
}

func NewGetPublicUserInfoArgs() *GetPublicUserInfoArgs {
	return &GetPublicUserInfoArgs{}
}

func (p *GetPublicUserInfoArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetPublicUserInfoArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Username = v
	}
	return nil
}

func (p *GetPublicUserInfoArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getPublicUserInfo_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetPublicUserInfoArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("username", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:username: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Username)); err != nil {
		return fmt.Errorf("%T.username (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:username: %s", p, err)
	}
	return err
}

func (p *GetPublicUserInfoArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetPublicUserInfoArgs(%+v)", *p)
}

type GetPublicUserInfoResult struct {
	Success           *PublicUserInfo               `thrift:"success,0"`
	NotFoundException *Errors.EDAMNotFoundException `thrift:"notFoundException,1"`
	SystemException   *Errors.EDAMSystemException   `thrift:"systemException,2"`
	UserException     *Errors.EDAMUserException     `thrift:"userException,3"`
}

func NewGetPublicUserInfoResult() *GetPublicUserInfoResult {
	return &GetPublicUserInfoResult{}
}

func (p *GetPublicUserInfoResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetPublicUserInfoResult) readField0(iprot thrift.TProtocol) error {
	p.Success = NewPublicUserInfo()
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success)
	}
	return nil
}

func (p *GetPublicUserInfoResult) readField1(iprot thrift.TProtocol) error {
	p.NotFoundException = Errors.NewEDAMNotFoundException()
	if err := p.NotFoundException.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.NotFoundException)
	}
	return nil
}

func (p *GetPublicUserInfoResult) readField2(iprot thrift.TProtocol) error {
	p.SystemException = Errors.NewEDAMSystemException()
	if err := p.SystemException.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.SystemException)
	}
	return nil
}

func (p *GetPublicUserInfoResult) readField3(iprot thrift.TProtocol) error {
	p.UserException = Errors.NewEDAMUserException()
	if err := p.UserException.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.UserException)
	}
	return nil
}

func (p *GetPublicUserInfoResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getPublicUserInfo_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.UserException != nil:
		if err := p.writeField3(oprot); err != nil {
			return err
		}
	case p.SystemException != nil:
		if err := p.writeField2(oprot); err != nil {
			return err
		}
	case p.NotFoundException != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetPublicUserInfoResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetPublicUserInfoResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.NotFoundException != nil {
		if err := oprot.WriteFieldBegin("notFoundException", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:notFoundException: %s", p, err)
		}
		if err := p.NotFoundException.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.NotFoundException)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:notFoundException: %s", p, err)
		}
	}
	return err
}

func (p *GetPublicUserInfoResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.SystemException != nil {
		if err := oprot.WriteFieldBegin("systemException", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:systemException: %s", p, err)
		}
		if err := p.SystemException.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.SystemException)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:systemException: %s", p, err)
		}
	}
	return err
}

func (p *GetPublicUserInfoResult) writeField3(oprot thrift.TProtocol) (err error) {
	if p.UserException != nil {
		if err := oprot.WriteFieldBegin("userException", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:userException: %s", p, err)
		}
		if err := p.UserException.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.UserException)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:userException: %s", p, err)
		}
	}
	return err
}

func (p *GetPublicUserInfoResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetPublicUserInfoResult(%+v)", *p)
}

type GetPremiumInfoArgs struct {
	AuthenticationToken string `thrift:"authenticationToken,1"`
}

func NewGetPremiumInfoArgs() *GetPremiumInfoArgs {
	return &GetPremiumInfoArgs{}
}

func (p *GetPremiumInfoArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetPremiumInfoArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.AuthenticationToken = v
	}
	return nil
}

func (p *GetPremiumInfoArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getPremiumInfo_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetPremiumInfoArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("authenticationToken", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:authenticationToken: %s", p, err)
	}
	if err := oprot.WriteString(string(p.AuthenticationToken)); err != nil {
		return fmt.Errorf("%T.authenticationToken (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:authenticationToken: %s", p, err)
	}
	return err
}

func (p *GetPremiumInfoArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetPremiumInfoArgs(%+v)", *p)
}

type GetPremiumInfoResult struct {
	Success         *Types.PremiumInfo          `thrift:"success,0"`
	UserException   *Errors.EDAMUserException   `thrift:"userException,1"`
	SystemException *Errors.EDAMSystemException `thrift:"systemException,2"`
}

func NewGetPremiumInfoResult() *GetPremiumInfoResult {
	return &GetPremiumInfoResult{}
}

func (p *GetPremiumInfoResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetPremiumInfoResult) readField0(iprot thrift.TProtocol) error {
	p.Success = Types.NewPremiumInfo()
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success)
	}
	return nil
}

func (p *GetPremiumInfoResult) readField1(iprot thrift.TProtocol) error {
	p.UserException = Errors.NewEDAMUserException()
	if err := p.UserException.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.UserException)
	}
	return nil
}

func (p *GetPremiumInfoResult) readField2(iprot thrift.TProtocol) error {
	p.SystemException = Errors.NewEDAMSystemException()
	if err := p.SystemException.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.SystemException)
	}
	return nil
}

func (p *GetPremiumInfoResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getPremiumInfo_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.SystemException != nil:
		if err := p.writeField2(oprot); err != nil {
			return err
		}
	case p.UserException != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetPremiumInfoResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetPremiumInfoResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.UserException != nil {
		if err := oprot.WriteFieldBegin("userException", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:userException: %s", p, err)
		}
		if err := p.UserException.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.UserException)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:userException: %s", p, err)
		}
	}
	return err
}

func (p *GetPremiumInfoResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.SystemException != nil {
		if err := oprot.WriteFieldBegin("systemException", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:systemException: %s", p, err)
		}
		if err := p.SystemException.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.SystemException)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:systemException: %s", p, err)
		}
	}
	return err
}

func (p *GetPremiumInfoResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetPremiumInfoResult(%+v)", *p)
}

type GetNoteStoreUrlArgs struct {
	AuthenticationToken string `thrift:"authenticationToken,1"`
}

func NewGetNoteStoreUrlArgs() *GetNoteStoreUrlArgs {
	return &GetNoteStoreUrlArgs{}
}

func (p *GetNoteStoreUrlArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetNoteStoreUrlArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.AuthenticationToken = v
	}
	return nil
}

func (p *GetNoteStoreUrlArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getNoteStoreUrl_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetNoteStoreUrlArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("authenticationToken", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:authenticationToken: %s", p, err)
	}
	if err := oprot.WriteString(string(p.AuthenticationToken)); err != nil {
		return fmt.Errorf("%T.authenticationToken (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:authenticationToken: %s", p, err)
	}
	return err
}

func (p *GetNoteStoreUrlArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetNoteStoreUrlArgs(%+v)", *p)
}

type GetNoteStoreUrlResult struct {
	Success         string                      `thrift:"success,0"`
	UserException   *Errors.EDAMUserException   `thrift:"userException,1"`
	SystemException *Errors.EDAMSystemException `thrift:"systemException,2"`
}

func NewGetNoteStoreUrlResult() *GetNoteStoreUrlResult {
	return &GetNoteStoreUrlResult{}
}

func (p *GetNoteStoreUrlResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetNoteStoreUrlResult) readField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 0: %s")
	} else {
		p.Success = v
	}
	return nil
}

func (p *GetNoteStoreUrlResult) readField1(iprot thrift.TProtocol) error {
	p.UserException = Errors.NewEDAMUserException()
	if err := p.UserException.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.UserException)
	}
	return nil
}

func (p *GetNoteStoreUrlResult) readField2(iprot thrift.TProtocol) error {
	p.SystemException = Errors.NewEDAMSystemException()
	if err := p.SystemException.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.SystemException)
	}
	return nil
}

func (p *GetNoteStoreUrlResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getNoteStoreUrl_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.SystemException != nil:
		if err := p.writeField2(oprot); err != nil {
			return err
		}
	case p.UserException != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetNoteStoreUrlResult) writeField0(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("success", thrift.STRING, 0); err != nil {
		return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Success)); err != nil {
		return fmt.Errorf("%T.success (0) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 0:success: %s", p, err)
	}
	return err
}

func (p *GetNoteStoreUrlResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.UserException != nil {
		if err := oprot.WriteFieldBegin("userException", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:userException: %s", p, err)
		}
		if err := p.UserException.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.UserException)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:userException: %s", p, err)
		}
	}
	return err
}

func (p *GetNoteStoreUrlResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.SystemException != nil {
		if err := oprot.WriteFieldBegin("systemException", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:systemException: %s", p, err)
		}
		if err := p.SystemException.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.SystemException)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:systemException: %s", p, err)
		}
	}
	return err
}

func (p *GetNoteStoreUrlResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetNoteStoreUrlResult(%+v)", *p)
}
